/**
 * SARL-MASSIM - Interface between the SARL agent-oriented language
 * and the MASSIM 2018+ game server
 * Copyright (C) 2017-2020 The SARL-MASSIM Authors.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package au.edu.rmit.agtgrp.agtcity.sarl.mw.aggregator

import eis.iilang.Function
import eis.iilang.ParameterList
import eis.iilang.Percept
import java.util.ArrayList
import java.util.Collection
import massim.protocol.scenario.city.data.ActionData
import massim.protocol.scenario.city.data.EntityData
import massim.protocol.scenario.city.data.ItemAmountData
import massim.protocol.scenario.city.data.WayPointData

/**
 * 
 * Responsible for the creation of Java objects from EiSMASSimPercept information provided by MASSIM gameserver:
 * https://github.com/ssardina-agts/agtcity-server/blob/master/docs/eismassim.md
 * 
 * It relies on EntityData class from massim.protocol.scenario.city.data.EntityData:
 * https://github.com/ssardina-agts/agtcity-server/blob/master/protocol/src/main/java/massim/protocol/scenario/city/data/EntityData.java
 * 
 * EntityData(Integer currentBattery, Integer maxBattery, Integer currentLoad, Integer maxLoad,
 * 				Integer vision, Integer skill, Integer speed,
 * 				ActionData lastAction,
 * 				String facilityName, List<WayPointData> route, List<ItemAmountData> items,
 * 				String agentName, String team, String role, double lat, double lon)
 */
class CityAgentEntityManager {

	public static val ENTITY_TYPES = newHashSet("entity")

	/** 
	 * Constructs a new record for an Entity from basic information
	 * 
	 * @param entityName - the name of the entity as in registration file
	 * @param entityRole - the role of the entity
	 * @param entityTeam - the team of the entity
	 * 
	 * @return an EntityData with the basic info filled
	 */
	static def createEntity(entityName : String, entityRole : String, entityTeam : String) : EntityData {
		return new EntityData(-1, -1, -1, -1, -1, -1, -1, null, null, null, null, entityName, entityTeam, entityRole,
			-1, -1);
	}

	/** 
	 * Constructs a new record for an Entity from a percept entity(name, team, lat, lon, role)
	 *  
	 * This is all we find out about entities perceived by other entities.
	 * For example team mates or opponents.
	 * 
	 * @param p - a single percept of type entity of form entity(name, team, lat, lon, role)
	 * @return an EntityData with the basic info filled
	 */
	static def createEntity(p : Percept) : EntityData {

		val playerName = Util.extractString(p.parameters.get(0))
		val playerTeam = Util.extractString(p.parameters.get(1))
		val lat = Util.extractDouble(p.parameters.get(2))
		val lon = Util.extractDouble(p.parameters.get(3))
		val playerRole = Util.extractString(p.parameters.get(4))
		return new EntityData(-1, -1, -1, -1, -1, -1, -1, null, null, null, null, playerName, playerTeam, playerRole,
			lat, lon);
	}

	/**
	 * Takes an entity and updates its internal representation based on the collection of percepts
	 * The structure of all possible percepts in the collection can be found here:
	 * https://github.com/ssardina-agts/agtcity-server/blob/master/docs/eismassim.md
	 * 
	 * @param entity - the EntityData to be updated
	 * @param precepts - the collection of percepts received from the server
	 * @return the step number in the percepts 
	 * @return entity fields updated
	 */
	static def updateEntity(entity : EntityData, percepts : Collection<Percept>) : int {
		var items : ArrayList<ItemAmountData> // item --> quantity
		var lastAction : String
		var lastActionParams = new ArrayList<String> 
		var lastActionResult : String
		
		var stepNo : int = -1
		

		// Navigate all the individual percepts and populate Entity fields
		for (p : percepts) {
				switch p.name {
				case "step": {
					stepNo = Util.extractInt(p.parameters.get(0))
				}
				case "lat": {
					entity.lat = Util.extractDouble(p.parameters.get(0))
				}
				case "lon": {
					entity.lon = Util.extractDouble(p.parameters.get(0))
				}
				case "lastAction": {
					lastAction = Util.extractString(p.parameters.get(0))
				}
				case "lastActionParams": {
					// lastActinParams([param1, param2, ...])
					if (p.parameters.get(0) !== null) {	// the action may not have had any parameter and is null
						val params = p.parameters.get(0) as ParameterList // [param1, param2...]
						for (param : params) { // build a list of stack data
							lastActionParams.add(Util.extractString(param))
						}
					}
				}
				case "lastActionResult": {
					lastActionResult = Util.extractString(p.parameters.get(0))
				}
				case "charge": {
					entity.charge = Util.extractInt(p.parameters.get(0))
				}
				case "load": {
					entity.load = Util.extractInt(p.parameters.get(0))
				}
				case "routeLength": {
					entity.routeLength = Util.extractInt(p.parameters.get(0))
				}
				case "facility": {
					entity.facility = Util.extractString(p.parameters.get(0))
				}
				case "hasItem": { // hasItem(name, qty)
					var itemName = Util.extractString(p.parameters.get(0))
					var itemQty = Util.extractInt(p.parameters.get(1))
					items.add(new ItemAmountData(itemName, itemQty))
				}
				case "role": {
					entity.role = Util.extractString(p.parameters.get(0))
				}
				case "team": {
					entity.team = Util.extractString(p.parameters.get(0))
				}
				case "name": {
					entity.name = Util.extractString(p.parameters.get(0))
				}
				case "route": {
					var params = p.parameters.get(0);
					var wps = params as ParameterList
					for (w : wps) {
							var f = w as Function
						var routeLat = Util.extractDouble(f.parameters.get(1))
						var routeLon = Util.extractDouble(f.parameters.get(2))
						var wayPoint = new WayPointData(-1, routeLat, routeLon)
						// TODO: do we need an index?
						var index = Util.extractInt(f.parameters.get(0));
						entity.route = new ArrayList<WayPointData>()
						entity.route.add(wayPoint)
					}
				}
			}
		} // for loop processing all percepts
		entity.items = items
		if (lastActionResult !== null) {
			entity.lastAction = new ActionData(lastAction, lastActionParams, lastActionResult)
		}
		return stepNo
	}

	/*
	 * Return a string with a summary of the player state: name, location, and battery level
	 *
	 * @param the entity we want to report
	 * @return a String with a reporting statement of the entity current (basic) state
	 */
	static def reportState(entity : EntityData) : String {
		var message : String = String.format("Report on entity %s (%s): at (%f, %f) with battery level %d and load %d",
			entity.name,
			entity.role,
			entity.lat.doubleValue,
			entity.lon.doubleValue,
			entity.charge.intValue,
			entity.load.intValue
			)
		return message
	   }
}
