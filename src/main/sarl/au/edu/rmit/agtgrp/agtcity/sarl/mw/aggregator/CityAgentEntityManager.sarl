/**
 * SARL-MASSIM - Interface between the SARL agent-oriented language
 * and the MASSIM 2018+ game server
 * Copyright (C) 2017-2020 The SARL-MASSIM Authors.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package au.edu.rmit.agtgrp.agtcity.sarl.mw.aggregator

import eis.iilang.Function
import eis.iilang.ParameterList
import eis.iilang.Percept
import java.util.ArrayList
import java.util.Collection
import massim.protocol.scenario.city.data.ActionData
import massim.protocol.scenario.city.data.EntityData
import massim.protocol.scenario.city.data.ItemAmountData
import massim.protocol.scenario.city.data.WayPointData
import java.util.Set
import java.util.stream.Collectors
import java.util.Collections

/**
 * 
 * Responsible for the creation of Java objects from EiSMASSimPercept information provided by MASSIM gameserver:
 * https://github.com/ssardina-agts/agtcity-server/blob/master/docs/eismassim.md
 * 
 * It relies on EntityData class from massim.protocol.scenario.city.data.EntityData:
 * https://github.com/ssardina-agts/agtcity-server/blob/master/protocol/src/main/java/massim/protocol/scenario/city/data/EntityData.java
 * 
 * EntityData(Integer currentBattery, Integer maxBattery, Integer currentLoad, Integer maxLoad,
 * 				Integer vision, Integer skill, Integer speed,
 * 				ActionData lastAction,
 * 				String facilityName, List<WayPointData> route, List<ItemAmountData> items,
 * 				String agentName, String team, String role, double lat, double lon)
 */
class CityAgentEntityManager {

	public static val ENTITY_TYPES = newHashSet("entity")

	public static val ENTITY_ATTRIBUTES : Set<String> =
		EntityData.getDeclaredFields().stream().map([f|f.getName()]).collect(Collectors.toSet())

	public static val ENTITY_LAST_ACTION_ATTRIBUTES : Set<String> = newHashSet("lastActionParams", "lastActionResult")

	/** 
	 * Constructs a new record for an Entity from basic information
	 * 
	 * @param entityName - the name of the entity as in registration file
	 * @param entityRole - the role of the entity
	 * @param entityTeam - the team of the entity
	 * 
	 * @return an EntityData with the basic info filled
	 */
	static def createEntity(entityName : String, entityRole : String, entityTeam : String) : EntityData {
		return new EntityData(-1, -1, -1, -1, -1, -1, -1, new ActionData(null, null, null), null, null, null,
			entityName, entityTeam, entityRole,
			-1, -1);
	}

	/** 
	 * Constructs a new record for an Entity from a percept entity(name, team, lat, lon, role)
	 *  
	 * This is all we find out about entities perceived by other entities.
	 * For example team mates or opponents.
	 * 
	 * @param p - a single percept of type entity of form entity(name, team, lat, lon, role)
	 * @return an EntityData with the basic info filled
	 */
	static def createEntity(p : Percept) : EntityData {

		val playerName = Util.extractString(p.parameters.get(0))
		val playerTeam = Util.extractString(p.parameters.get(1))
		val lat = Util.extractDouble(p.parameters.get(2))
		val lon = Util.extractDouble(p.parameters.get(3))
		val playerRole = Util.extractString(p.parameters.get(4))
		return new EntityData(-1, -1, -1, -1, -1, -1, -1, new ActionData(null, null, null), null, null, null, playerName, playerTeam, playerRole,
			lat, lon);
	}

	/** 
	 * Takes an entity and updates its internal representation based on the collection of percepts
	 * The structure of all possible percepts in the collection can be found here:
	 * https://github.com/ssardina-agts/agtcity-server/blob/master/docs/eismassim.md
	 * 
	 * @param entity - the EntityData to be updated
	 * @param precepts - the collection of percepts received from the server
	 * @return entity fields names that were updated
	 */
	static def updateEntity(entity : EntityData, percepts : Collection<Percept>) : Set<String> {
		val attr_changed = newHashSet()
		/* Collect the percepts relevant to the entity. */
		val entityPercepts = percepts
			.stream()
			.filter([ percept : Percept |
				ENTITY_ATTRIBUTES.contains(percept.name) || ENTITY_LAST_ACTION_ATTRIBUTES.contains(percept.name)
			]).collect(Collectors.toList())
		
		/* Check that we received the right number of attributes. */
		if (entityPercepts.length != ENTITY_ATTRIBUTES.size() + ENTITY_LAST_ACTION_ATTRIBUTES.size()) {
			var expecting = ENTITY_ATTRIBUTES.toList()
			expecting.addAll(ENTITY_LAST_ACTION_ATTRIBUTES)
			var received = entityPercepts.stream().map([p | return p.name]).collect(Collectors.toList())
			Collections.sort(expecting)
			Collections.sort(received)
			System.out.println("WARNING: The entity attributes received from the server are different to what was expected.")
			System.out.println("We expected:")
			System.out.println(String.join("\n", expecting))
			
			System.out.println("Server percept only has:")
			System.out.println(String.join("\n", received))
		}

		/* Compare and update entity attributes, maintain list of what changed. */
		for (p : entityPercepts) {
			switch p.name {
				case "name": {
					val name = Util.extractString(p.parameters.get(0))
					/* Safely checking equality in event of both being null. */
					if ((name !== null && !name.equals(entity.name))
						|| (entity.name !== null && !entity.name.equals(name))
					) {
						entity.name = name
						attr_changed.add("name")
					}
				}
				case "charge": {
					val charge = Util.extractInt(p.parameters.get(0))
					if (charge != entity.charge) {
						entity.charge = charge
						attr_changed.add("charge")
					}
				}
				case "chargeMax": {
					val chargeMax = Util.extractInt(p.parameters.get(0))
					if (chargeMax != entity.chargeMax) {
						entity.chargeMax = chargeMax
						attr_changed.add("chargeMax")
					}
				}
				case "load": {
					val load = Util.extractInt(p.parameters.get(0))
					if (load != entity.load) {
						entity.load = load
						attr_changed.add("load")
					}
				}
				case "loadMax": {
					val loadMax = Util.extractInt(p.parameters.get(0))
					if (loadMax != entity.loadMax) {
						entity.loadMax = loadMax
						attr_changed.add("loadMax")
					}
				}
				case "vision": {
					val vision = Util.extractInt(p.parameters.get(0))
					if (vision != entity.vision) {
						entity.vision = vision
						attr_changed.add("vision")
					}
				}
				case "skill": {
					val ^skill = Util.extractInt(p.parameters.get(0))
					if (^skill != entity.^skill) {
						entity.^skill = ^skill
						attr_changed.add("skill")
					}
				}
				case "speed": {
					val speed = Util.extractInt(p.parameters.get(0))
					if (speed != entity.speed) {
						entity.speed = speed
						attr_changed.add("speed")
					}
				}
				case "lastAction": {
					val lastAction = Util.extractString(p.parameters.get(0))
					/* Safely checking equality in event of both being null. */
					if ((lastAction !== null && !lastAction.equals(entity.name)) ||
						(entity.lastAction !== null && !entity.lastAction.equals(lastAction))) {
						entity.lastAction.type = lastAction
						attr_changed.add("lastAction")
					}
				}
				case "lastActionParams": {
					// lastActionParams([param1, param2, ...])
					val lastActionParams = newArrayList()
					if (p.parameters.get(0) !== null) {	// the action may not have had any parameter and is null
						val params = p.parameters.get(0) as ParameterList // [param1, param2...]
						for (param : params) { // build a list of stack data
							lastActionParams.add(Util.extractString(param))
						}
					}
					if(!Util.equal(lastActionParams, entity.lastAction.params)) {
						entity.lastAction.params = lastActionParams
						attr_changed.add("lastAction")
					}
				}
				case "lastActionResult": {
					val lastActionResult = Util.extractString(p.parameters.get(0))
					/* Safely checking equality in event of both being null. */
					if ((lastActionResult !== null && !lastActionResult.equals(entity.lastAction.result)) ||
						(entity.lastAction.result !== null && !entity.lastAction.result.equals(lastActionResult))) {
						entity.lastAction.result = lastActionResult
						attr_changed.add("lastAction")
					}
				}
				case "facility": {
					val facility = Util.extractString(p.parameters.get(0))
					/* Safely checking equality in event of both being null. */
					if ((facility !== null && !facility.equals(entity.facility)) ||
						(entity.facility !== null && !entity.facility.equals(facility))) {
						entity.facility = facility
						attr_changed.add("facility")
					}
				}
				case "routeLength": {
					val routeLength = Util.extractInt(p.parameters.get(0))
					if (routeLength != entity.routeLength) {
						entity.routeLength = routeLength
						attr_changed.add("routeLength")
					}
				}
				case "hasItem": { // hasItem(name, qty)
					var itemName = Util.extractString(p.parameters.get(0))
					var itemQty = Util.extractInt(p.parameters.get(1))
					// TODO
					//items.add(new ItemAmountData(itemName, itemQty))
				}
				case "role": {
					entity.role = Util.extractString(p.parameters.get(0))
				}
				case "team": {
					entity.team = Util.extractString(p.parameters.get(0))
				}
				case "route": {
					var params = p.parameters.get(0);
					var wps = params as ParameterList
					for (w : wps) {
							var f = w as Function
						var routeLat = Util.extractDouble(f.parameters.get(1))
						var routeLon = Util.extractDouble(f.parameters.get(2))
						var wayPoint = new WayPointData(-1, routeLat, routeLon)
						// TODO: do we need an index?
						var index = Util.extractInt(f.parameters.get(0));
						entity.route = new ArrayList<WayPointData>()
						entity.route.add(wayPoint)
					}
				}
				case "lat": {
					val lat = Util.extractDouble(p.parameters.get(0))
					if (lat != entity.lat) {
						entity.lat = lat
						attr_changed.add("lat")
					}
				}
				case "lon": {
					val lon = Util.extractDouble(p.parameters.get(0))
					if (lon != entity.lon) {
						entity.lon = lon
						attr_changed.add("lon")
					}
				}
			}
		}
		return attr_changed
	}

	/* 
	 * Return a string with a summary of the player state: name, location, and battery level
	 *
	 * @param the entity we want to report
	 * @return a String with a reporting statement of the entity current (basic) state
	 */
	static def reportState(entity : EntityData) : String {
		var message : String = String.format("Report on entity %s (%s): at (%f, %f) with battery level %d and load %d",
			entity.name,
			entity.role,
			entity.lat.doubleValue,
			entity.lon.doubleValue,
			entity.charge.intValue,
			entity.load.intValue
			)
		return message
	   }
}
