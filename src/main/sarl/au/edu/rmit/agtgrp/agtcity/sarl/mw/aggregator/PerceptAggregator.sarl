/** 
 * SARL-MASSIM - Interface between the SARL agent-oriented language 
 * and the MASSIM 2017 server
 * Copyright (C) 2017 The SARL-MASSIM Authors.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package au.edu.rmit.agtgrp.agtcity.sarl.mw.aggregator

import au.edu.rmit.agtgrp.agtcity.sarl.mw.entities.ActionResult
import au.edu.rmit.agtgrp.agtcity.sarl.mw.entities.CityDataCreator
import au.edu.rmit.agtgrp.agtcity.sarl.mw.entities.EntityAgent
import au.edu.rmit.agtgrp.agtcity.sarl.mw.entities.TeamEntityAgent
import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.E_ActionStatusInfo
import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.E_ChargingStationInfo
import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.E_DumpInfo
import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.E_JobInfo
import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.E_ResourceInfo
import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.E_ShopInfo
import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.E_StorageInfo
import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.E_TellEntityInfo
import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.E_TellPlayerTeamInfo
import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.E_WorkshopInfo
import eis.iilang.Percept
import java.util.ArrayList
import java.util.Collection
import java.util.HashMap
import java.util.HashSet
import java.util.List
import java.util.Set
import massim.protocol.scenario.city.data.AuctionJobData
import massim.protocol.scenario.city.data.ChargingStationData
import massim.protocol.scenario.city.data.DumpData
import massim.protocol.scenario.city.data.FacilityData
import massim.protocol.scenario.city.data.JobData
import massim.protocol.scenario.city.data.ResourceNodeData
import massim.protocol.scenario.city.data.ShopData
import massim.protocol.scenario.city.data.StorageData
import massim.protocol.scenario.city.data.WellData
import massim.protocol.scenario.city.data.WorkshopData

/** 
 * @author boblo
 * 
 * Class used to collect all of the percepts from all of the agents in MASSIM to minimize event emission.
 */
class PerceptAggregator {

	/*
	 * These data structures keep track of all the information known so far from the game, as received
	 * from all agent players in the team
	 * 
	 * The are all hash maps mapping the name id to an object storing the corresponding information
	 */
	var players_team : HashMap<String, TeamEntityAgent>
	var players_opp : HashMap<String, EntityAgent>
	var actionResults : HashMap<String, ActionResult>
	var money : double

	var jobs : HashMap<String, JobData>	// holds regular jobs and auction jobs (subclass AuctionJobData)

	var facilities : HashMap<String, FacilityData>
	var chargingStations : HashMap<String, ChargingStationData>
	var dumps : HashMap<String, DumpData>
	var shops : HashMap<String, ShopData>
	var storages : HashMap<String, StorageData>
	var workshops : HashMap<String, WorkshopData>
	var resources : HashMap<String, ResourceNodeData>
	var wells: HashMap<String, WellData>

	
	/**
	 * Constructor that initializes all of the HashMaps to empty
	 */
	new() {
		this.players_team = new HashMap()
		this.players_opp = new HashMap()
		this.actionResults = new HashMap()
		this.money = 0
		
		this.jobs = new HashMap()
		
		this.facilities = new HashMap()
		this.chargingStations = new HashMap()
		this.dumps = new HashMap()
		this.storages = new HashMap()
		this.shops = new HashMap()
		this.workshops = new HashMap()
		this.resources = new HashMap()
	}
	
	
	
	
	/**
	 * Add the information relating to team members to the this.players_team HashMap.
	 * 
	 * @param source - list of agents that received this percept from MASSIM. 
	 * @param PlayerState - the observed entity
	 */
	def addPlayerTeam(source : String, teamEntity : TeamEntityAgent) {
		players_team.put(source, teamEntity)
	}

	/** 
	 * Add the information relating to opposition team to the this.players_opp HashMap.
	 * 
	 * @param source - list of agents that received this percept from MASSIM. 
	 * @param PlayerState - the observed entity
	 */
	def addPlayerOpposition(source : String, entityAgent : EntityAgent) {
		players_opp.put(source, entityAgent)
	}


	/** 
	 * Add the information relating to all opposition agents from EntityBuffer
	 * 
	 */
	 // TODO: can we get rid of this? Do we need EntityBuffer complex data?
	def addPlayerOpposition() {
		for (e : EntityBuffer.entities.keySet) {
			if (!this.players_team.keySet.contains(e)) { // add only if they are not agents of the team
				addPlayerOpposition(e, (EntityBuffer.entities.get(e)))
			}
		}
	}

	/**
	 * Store the amount of money the team has.
	 * 
	 * @param money - the amount of money perceived our team to have.
	 */
	def addMoneyPercept(money : double) {
		this.money = money
	}
	

	
	def fillFacilitiesAndJobs(percepts : Collection<Percept>) {
		percepts.forEach([ p : Percept |
			if (CityDataCreator.FACILITY_TYPES.contains(p.name)) {
				val facility = CityDataCreator.createFacility(p)
				this.facilities.put(facility.name, facility)
				
				switch (p.name) {
					case "chargingStation": {
						this.chargingStations.put(facility.name, facility as ChargingStationData)
						}
					case "dump": {
						this.dumps.put(facility.name, facility as DumpData)
						}
					case "shop": {
						this.shops.put(facility.name, facility as ShopData)
						}
					case "storage": {
						this.storages.put(facility.name, facility as StorageData)
						}
					case "workshop": {
						this.workshops.put(facility.name, facility as WorkshopData)
						}
					case "resourceNode": {
						this.resources.put(facility.name, facility as ResourceNodeData)
						}
					case "well": {
						this.wells.put(facility.name, facility as WellData)
						}
					}				
			} else if (CityDataCreator.JOB_TYPES.contains(p.name)) {
//				val job = CityDataCreator.createJob(p)
//				this.jobs.put(job.getId(), job)
			}
		]);

	}	
	
	/**
	 * Get the action results for an agent sources. 
	 * 
	 * @param source - the EI source (e.g., player_connectionA1) of the percept is referring to. 
	 * @param percepts - the collection of percepts received from MASSIM
	 */
	def addActionResults(source : String, percepts : Collection<Percept>){
		
		var action : String
		var success : String
		
		for(p : percepts){
			switch(p.name){
				case "lastAction" : {
					action = Util.extractString(p.parameters.get(0))
				}
				case "lastActionResult" : {
					success = Util.extractString(p.parameters.get(0))
				}
			}
		}
		this.actionResults.put(source, new ActionResult(action, success))
	}
	
	
	
	
	
	
	
	
	///////////////////////////////////////////////////////////////////////////////
	//	GETTERS
	// /////////////////////////////////////////////////////////////////////////////

	/*
	 * Methods to extract individual information from percepts
	 */

	/** 
	 * Get the set of shop names
	 * 
	 * @returns the set of names of known shops
	 */
	def getShopsNames() : Set<String> {
		return shops.keySet()
	}

	/** 
	 * Get the set of facilitiesnames
	 * 
	 * @returns the set of names of known facilities
	 */
	def getFacilitiesNames() : Set<String> {
		return facilities.keySet()
	}






	///////////////////////////////////////////////////////////////////////////////
	//	EVENT CREATION FROM DATA
	// /////////////////////////////////////////////////////////////////////////////
	
	
	/** 
	 * Build a set E_TellPlayerTeamInfo events
	 * 		To send information about team members
	 * 
	 * @return an set of E_TellPlayerTeamInfo events containing the data for each player team-mate
	 */
	def getTeamMemberPercepts() : Set<E_TellEntityInfo> {
		var events = new HashSet<E_TellEntityInfo>()

		for (agentName : players_team.keySet) {
			var sources = new HashSet<String>()
			sources.add(agentName)
			events.add(new E_TellPlayerTeamInfo(sources, players_team.get(agentName)))
		}
		return events
	}

	/** 
	 * Build a set E_TellEntityInfoevents
	 * 		To send information about opposition entities
	 * 
	 * @return an set of E_TellEntityInfo events 
	 */
	def getGameEntityPercepts() : Set<E_TellEntityInfo> {
		var events = new HashSet<E_TellEntityInfo>()

		for (entityName : players_opp.keySet) {
			var ep = new E_TellEntityInfo(players_team.keySet, players_opp.get(entityName))
			events.add(ep);
		}
		return events

	}

	/** 
	 * Build a set E_ActionStatusInfo
	 * 	To send information about all action result from team members
	 * 
	 * @return an set of E_ActionStatusInfo events 
	 */
	def getActionPercepts() : List<E_ActionStatusInfo>{
		var events = new ArrayList<E_ActionStatusInfo>
		
		for (agentName : actionResults.keySet){
			var nameSet = new HashSet<String>()
			nameSet.add(agentName)
			
			var ap = new E_ActionStatusInfo(nameSet, actionResults.get(agentName))
			events.add(ap)
		}
		return events
		
	}
	
	
	/**
	 * Tools to get FACILITIES
	 * 	shops
	 *  charging station
	 *  workshops
	 *  dumps
	 *  storage
	 *  resource nodes
	 * 
	 * https://github.com/agentcontest/massim/blob/massim-2017-1.7/docs/scenario.md#facilities
	 */



	/** 
	 * Build a set E_ShopInfo
	 * To send information about all shops known
	 * 
	 * @return an set of E_ShopInfo events 
	 */
	def getShopSensedPercepts() : List<E_ShopInfo> {
		var events = new ArrayList<E_ShopInfo>

		for (facilityname : shops.keySet) {
			var ssp = new E_ShopInfo(players_team.keySet, shops.get(facilityname));
			events.add(ssp)
		}
		return events
	}

	/** 
	 * Build a set E_ChargingStationInfo
	 * To send information about all charging stations known
	 * 
	 * @return an set of E_ChargingStationInfo events 
	 */
	def getChargingStationSensedPercepts() : List<E_ChargingStationInfo>{
		var events = new ArrayList<E_ChargingStationInfo>
		
		for (stationName : chargingStations.keySet){
			var cssp = new E_ChargingStationInfo(players_team.keySet, chargingStations.get(stationName));
			events.add(cssp)
		}
		return events
	}

	/** 
	 * Build a set E_WorkshopInfo
	 * To send information about all workshops known
	 * 
	 * @return an set of E_WorkshopInfo events 
	 */
	def getWorkshopSensedPercepts() : List<E_WorkshopInfo> {
		var events = new ArrayList<E_WorkshopInfo>

		for (facilityname : workshops.keySet) {
			var ssp = new E_WorkshopInfo(players_team.keySet, workshops.get(facilityname));
			events.add(ssp)
		}
		return events
	}

	/** 
	 * Build a set E_DumpInfo
	 * To send information about all dumps known
	 * 
	 * @return an set of E_DumpInfo events 
	 */
	def getDumpSensedPercepts() : List<E_DumpInfo>{

		var events = new ArrayList<E_DumpInfo>

		for (facilityname : dumps.keySet) {
			var dsp = new E_DumpInfo(players_team.keySet, dumps.get(facilityname));
			events.add(dsp)
		}
		return events
	}

	/** 
	 * Build a set E_StorageInfo
	 * To send information about all storage known
	 * 
	 * @return an set of E_StorageInfo events 
	 */
	def getStorageSensedPercepts() : List<E_StorageInfo> {
		var events = new ArrayList<E_StorageInfo>

		for (facilityname : storages.keySet) {
			var ssp = new E_StorageInfo(players_team.keySet, storages.get(facilityname));
			events.add(ssp)
		}
		return events 
	}

	/** 
	 * Build a set E_ResourceInfo
	 * To send information about all resources known
	 * 
	 * @return an set of E_ResourceInfo events 
	 */
	def getResourceSensedPercepts() : List<E_ResourceInfo> { 
		var events = new ArrayList<E_ResourceInfo>

		for (resourceName : resources.keySet) {
			var rsp = new E_ResourceInfo(players_team.keySet, resources.get(resourceName));
			events.add(rsp)
		}
		return events 
	}

	/**
	 * Build a list of E_JobInfo events with regular jobs
	 * 
	 * @returns a list of events each containing a regular job 
	 */
	def getRegularJobEvents() : List<E_JobInfo> {
		var events = new ArrayList<E_JobInfo>

		for (job : jobs.entrySet) {
			if (! (job.value instanceof AuctionJobData)) {
				var ev = new E_JobInfo(players_team.keySet, job.value);
				events.add(ev)
				}
		}
		return events
	}

	/** 
	 * Build a list of E_JobInfo events with auction jobs data
	 * 
	 * @returns a list of events each containing a auction job  data
	 */
	 def getAuctionJobPercepts() : List<E_JobInfo> {
		var events = new ArrayList<E_JobInfo>

		for (job : jobs.entrySet) {
			if (job.value instanceof AuctionJobData) {
				var ev = new E_JobInfo(players_team.keySet, job.value as AuctionJobData, "auction");
				events.add(ev)
				}
		}
		return events
	}
	
	
	



}
