/** 
 * SARL-MASSIM - Interface between the SARL agent-oriented language 
 * and the MASSIM 2017 server
 * Copyright (C) 2017 The SARL-MASSIM Authors.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package au.edu.rmit.agtgrp.agtcity.sarl.mw.agents.scheduler

import eis.EnvironmentInterfaceStandard
import eis.exceptions.ActException
import eis.iilang.Percept
import eis.iilang.Action


import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.Schedules
import io.sarl.core.AgentSpawned

import java.util.Collection
import java.util.Map
import java.util.ArrayList
import java.util.HashMap
import java.util.UUID
import java.util.Set
import java.util.HashSet
import java.nio.file.Paths

import au.edu.rmit.agtgrp.agtcity.sarl.mw.capacities.C_Reporting
import au.edu.rmit.agtgrp.agtcity.sarl.mw.capacities.C_MassimTalking
import au.edu.rmit.agtgrp.agtcity.sarl.mw.skills.S_ConsoleReporting
import au.edu.rmit.agtgrp.agtcity.sarl.mw.skills.S_MassimTalking

import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.E_AgentAction
import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.E_SenseEnvironment

import au.edu.rmit.agtgrp.agtcity.sarl.mw.aggregator.PerceptAggregator
import au.edu.rmit.agtgrp.agtcity.sarl.mw.aggregator.PlayerStateBuilder
import au.edu.rmit.agtgrp.agtcity.sarl.mw.aggregator.Util
import au.edu.rmit.agtgrp.agtcity.sarl.mw.aggregator.SimStartBuffer

import au.edu.rmit.agtgrp.agtcity.sarl.mw.utils.ConfHandler



import eis.exceptions.PerceiveException
import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.E_TellEntityInfo
import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.E_FacilityInfo
import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.E_WorkshopInfo
import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.E_JobInfo

/** 
 * @author Sebastian Sardina (ssardina@gmail.com)
 * 
 */
@SuppressWarnings("potential_field_synchronization_problem")
agent SchedulerAgent {
    uses Logging, DefaultContextInteractions
	uses Lifecycle
	uses C_Reporting, C_MassimTalking
	uses Schedules

	val myName = "Scheduler-Agent"

    var ei : EnvironmentInterfaceStandard // the handler to the interface
	
	// These are the connection players we will control
	var myConnections = #["connectionA1", "connectionA2", "connectionA3", "connectionA4", "connectionA5",
		"connectionA6"]
    

	var agents : Map<String, UUID> = new HashMap<String, UUID>() // map game player --> UUID of SARL agent
	var agentsPendingToInitialize : Set<UUID> = new HashSet<UUID>() 	// set of all SARL agents in the system

	// To keep track of agents spawned succesfully
	var noToSpawn : int = 0 // number of agents to be spawn in total
	var noSpawn : int = 0 // number of agents already spawn successfully and alive!
	val noSpawn_lock : Object = new Object()

    on Initialize {
		val eiMassimConfigFile = "eismassimconfig.json"
		val eiAgentConfigFile = "agentsconfig.json"

		var args = newArrayList(occurrence.parameters)
        var eiConfigDir : String = ""

		// Give reporting skill via console
		setSkill(new S_ConsoleReporting("Scheduler Agent"), C_Reporting)
		// 4 - debug, 3 - INFO, 2 - WARNING
		setLogLevel(3)
		
		info("PHASE 1: INSTANTIATING SKILL TO COMMUNICATE WITH GAME SERVER")
        // get the directory for the config files (server + players) if not part of the parameters
        if (args.length != 0)
            eiConfigDir = args.get(0) as String
        else {
            info("PHASE 1.2: CHOOSE CONFIGURATION")
            eiConfigDir = ConfHandler.getConfDir()
        }
		debug("Configuration settings: 
				\t My SARL agent name: {0}
				\t Directory of configuration files: {1}
				\t File containing authentication and sever info: {2}", myName, eiConfigDir, eiMassimConfigFile)

		// Give agent ability to talk to MASSIM server
		setSkill(new S_MassimTalking(Paths.get(eiConfigDir, eiMassimConfigFile)), C_MassimTalking)

		agent_says("PHASE 2: INITIALIZING EI WITH FILE {0} TO CONTROL CONNECTIONS: {1} ", eiMassimConfigFile,
			myConnections.toString)
		if (myConnections !== null) myConnections.forEach( [player : String|MT_addPlayerByName(player)]) // entities to control
		// this creates the EI and starts it, and authenticates all entities to server (may take time)
		if (MT_initialize()) { 
			agent_says("The EI is now initialized, entities are being authenticated...")
		} else {
			agent_says("Something wrong when initializing the EI")
			killMe
		}

		in(2000) [
			info("PHASE 3: SPAWNING WORKER SARL AGENTS FOR EACH PLAYER")
			noToSpawn = MT_getPlayersNames().size	// we will spawn this number of SARL agents
			MT_getPlayersNames().forEach [ playerName : String |
				synchronized (agentsPendingToInitialize) {
					val UUID = spawn(DummyAgent, playerName) // Spawn a dummy agent called playerName
					agent_says("A SARL agent {0} has been SPAWN to control game player {1}", UUID.toString, playerName)
					agents.put(playerName, UUID);
					agentsPendingToInitialize.add(UUID)
				}
			]
		]
	} // INITIALIZE


	// Report that a dummy agent (not myself!) has born
	// Be careful: occurrence.fromMe is true IFF I was the one show spawned the agent (not emmitted the event!)
	// check issue bug: https://github.com/sarl/sarl/issues/849
	on AgentSpawned [!(occurrence.agentIdentifiers.get(0) == this.ID)] {
		val agent_UUID = occurrence.agentIdentifiers.get(0)
		val agent_type = occurrence.agentType

		debug("An Agent {0} (of type: {1}) has finished spawning", agent_UUID, agent_type)
		synchronized (agentsPendingToInitialize) {
			if (agentsPendingToInitialize.remove(agent_UUID)) {
				noSpawn = noSpawn + 1
				agent_says("Agent {0} (no. {1}; type: {2}) has been created successfully and is now alive!", agent_UUID,
					noSpawn, agent_type)
				debug("Total agents to be spawn: {0} - Agents spawn already: {1}", noToSpawn, noSpawn)

				// No more to agents to wait, start sensing!
				if (agentsPendingToInitialize.empty && noSpawn == noToSpawn) {
					agent_shouts("All {0} agent-players have been created, now starting to sense and act....", noSpawn)
					info("PHASE 4: ALL INITIALIZED, READY TO GO!!!!!!!!!")
					emit(new E_SenseEnvironment())
				} 
			} else {
				warning("Strange, an agent {0} has spawned but I was not waiting for it....", agent_UUID, agent_type)
			}
		
		}
	}









	on E_SenseEnvironment {
		// Initializes to empty three static data buffers for entities, sim-start and
		if (Util.initDataBuffers()) {}
		
		// This is done every 1000ms
		every(1000)[
			var aggregator = new PerceptAggregator(); // collect all the percepts from all agents
			// ////////////////////////////////////////////////////////////////////////
            // First all sensing is aggregated into *aggregator* object for removing redundant sensing across agents
            agents.keySet.forEach([ playerName: String |
				try {
					// First get the percepts of playerName
					// https://github.com/agentcontest/massim/blob/master/docs/scenario.md#percepts
					// https://github.com/agentcontest/massim/blob/master/docs/eismassim.md
					//
					agent_says("Getting percepts (blocking) for player *{0}*", playerName)

					// PLAYER SENSING EXAMPLE GETTING ALL PERCEPTS FOR ALL PLAYER TYPE OF ENTITY (USUALLY JUST 1):
					//
					// allPercepts Map<String, Collection<Percept>>: {connectionA2=[item(item4,41,tools([]),parts([])), simStart, item(item2,44,tools([]),parts([])), maxLat(19.45), item(item0,21,tools([]),parts([])), item(tool2,33,tools([]),parts([])), team(A), item(tool6,38,tools([]),parts([])), item(item14,354,tools([tool4,tool2]),parts([[item3,3],[item13,1],[item9,1]])), role(drone,5,100,250,[tool4,tool6,tool7]), item(tool0,35,tools([]),parts([])), minLat(19.3), item(item12,64,tools([tool7,tool5]),parts([[item7,1],[item11,1]])), item(item8,94,tools([tool1,tool5]),parts([[item7,3],[item0,1],[item4,1]])), item(item9,126,tools([tool1]),parts([[item2,3],[item6,1]])), item(tool4,47,tools([]),parts([])), item(item5,42,tools([]),parts([])), item(item6,15,tools([]),parts([])), item(item1,43,tools([]),parts([])), item(tool5,34,tools([]),parts([])), item(tool1,28,tools([]),parts([])), id(2017-Mexico-City-Test), steps(1000), map(mexico-city), item(item11,60,tools([tool3]),parts([[item7,2],[item6,1]])), item(tool3,37,tools([]),parts([])), item(item10,166,tools([]),parts([[item0,3],[item4,3],[item6,1]])), item(item7,30,tools([]),parts([])), item(tool7,48,tools([]),parts([])), seedCapital(50000), minLon(-99.2), maxLon(-99.0), item(item13,270,tools([tool1]),parts([[item4,1],[item8,3],[item2,1]])), item(item3,36,tools([]),parts([])), storage(storage13,19.44019,-99.18794,14889,0,[]), storage(storage7,19.35245,-99.04573,13230,0,[]), storage(storage14,19.42892,-99.10555,8183,0,[]), timestamp(1514672806565), route([]), shop(shop4,19.35746,-99.19067,5,[item(item0,74,20),item(item1,84,11),item(item2,84,7),item(item5,63,19),item(item6,98,17),item(item7,19,14)]), dump(dump8,19.39958,-99.13238), chargingStation(chargingStation15,19.42892,-99.11276,107), workshop(workshop6,19.40399,-99.18714), shop(shop10,19.39051,-99.03542,4,[item(item1,86,7),item(item2,81,12),item(item3,122,12),item(item5,69,6),item(item7,14,16),item(tool2,45,16),item(tool4,47,11),item(tool6,124,17),item(tool7,48,8)]), entity(agentA5,A,19.40736,-99.05846,motorcycle), workshop(workshop5,19.35316,-99.03779), dump(dump9,19.41991,-99.07416), entity(agentA7,A,19.33828,-99.12541,motorcycle), shop(shop1,19.32016,-99.12328,3,[item(item1,91,18),item(tool0,93,10),item(tool1,72,16),item(tool5,107,9),item(tool6,138,9),item(tool7,39,6)]), lastActionResult(successful), chargingStation(chargingStation1,19.30823,-99.14639,123), entity(agentA19,A,19.37567,-99.11684,car), chargingStation(chargingStation3,19.30137,-99.04509,91), workshop(workshop7,19.39895,-99.0919), entity(agentA25,A,19.36242,-99.02579,truck), chargingStation(chargingStation12,19.3876,-99.07765,128), storage(storage2,19.32609,-99.09198,12589,0,[]), dump(dump13,19.4271,-99.03601), shop(shop0,19.33569,-99.16989,1,[item(item4,101,13),item(tool0,84,20),item(tool3,126,18),item(tool5,108,16),item(tool6,101,12)]), workshop(workshop9,19.44614,-99.19569), chargingStation(chargingStation4,19.30961,-99.03329,119), storage(storage12,19.39664,-99.03379,9594,0,[]), workshop(workshop10,19.44087,-99.14081), step(0), entity(agentA4,A,19.43752,-99.08263,drone), entity(agentA27,A,19.33246,-99.10792,truck), lastActionParams([]), chargingStation(chargingStation5,19.35958,-99.1865,73), dump(dump7,19.36426,-99.03392), storage(storage0,19.32686,-99.19329,9604,0,[]), entity(agentA24,A,19.37424,-99.05352,truck), entity(agentA17,A,19.37227,-99.13973,car), dump(dump0,19.33927,-99.18741), chargingStation(chargingStation2,19.33813,-99.08956,98), facility(), entity(agentA21,A,19.3971,-99.05624,truck), chargingStation(chargingStation9,19.35086,-99.0163,53), lastAction(noAction), entity(agentA18,A,19.39969,-99.02349,car), shop(shop2,19.32144,-99.0697,3,[item(item0,90,14),item(item6,91,10),item(tool5,133,19)]), workshop(workshop3,19.37344,-99.09335), shop(shop13,19.44068,-99.1147,5,[item(item5,69,6),item(tool0,69,19),item(tool1,85,20)]), storage(storage6,19.3626,-99.11757,13702,0,[]), chargingStation(chargingStation0,19.31722,-99.18127,140), dump(dump10,19.38139,-99.02397), entity(agentA12,A,19.33519,-99.09793,motorcycle), entity(agentA20,A,19.40171,-99.19236,car), storage(storage1,19.30076,-99.12679,7824,0,[]), entity(agentA3,A,19.40928,-99.11384,drone), dump(dump5,19.34982,-99.14985), shop(shop9,19.39585,-99.04156,1,[item(item0,70,18),item(item3,95,9),item(item4,141,20),item(item7,16,6),item(tool4,37,20),item(tool5,121,17),item(tool6,120,8),item(tool7,45,9)]), chargingStation(chargingStation7,19.37113,-99.11836,54), storage(storage5,19.36626,-99.12744,11163,0,[]), chargingStation(chargingStation8,19.3591,-99.05357,111), entity(agentA1,A,19.37562,-99.00317,drone), chargingStation(chargingStation11,19.41131,-99.14265,130), storage(storage8,19.3902,-99.18367,12169,0,[]), lon(-99.17834), shop(shop14,19.42382,-99.03512,3,[item(item1,99,17),item(item3,105,9),item(item4,139,19),item(item7,14,20),item(tool0,72,13),item(tool4,36,15),item(tool6,97,19)]), entity(agentA13,A,19.43401,-99.06124,car), chargingStation(chargingStation10,19.38384,-99.17284,122), dump(dump11,19.42418,-99.17356), workshop(workshop11,19.43077,-99.02892), storage(storage11,19.41385,-99.05545,13467,0,[]), entity(agentA23,A,19.44255,-99.15922,truck), shop(shop12,19.43897,-99.14012,2,[item(item1,82,10),item(tool2,56,15),item(tool3,118,19)]), entity(agentA9,A,19.32065,-99.13607,motorcycle), entity(agentA26,A,19.38986,-99.14356,truck), storage(storage10,19.40745,-99.10503,11491,0,[]), entity(agentA10,A,19.3473,-99.19299,motorcycle), actionID(0), requestAction, storage(storage3,19.30459,-99.01727,14934,0,[]), shop(shop7,19.39279,-99.1337,5,[item(item0,67,17),item(item1,92,13),item(item2,87,5),item(tool0,68,11),item(tool7,47,17)]), entity(agentA14,A,19.44007,-99.14925,car), entity(agentA11,A,19.44882,-99.19551,motorcycle), entity(agentA22,A,19.33237,-99.02805,truck), dump(dump2,19.31402,-99.05739), dump(dump12,19.44191,-99.08681), shop(shop8,19.38367,-99.10324,3,[item(item2,84,7),item(item4,144,16),item(item7,17,8),item(tool1,82,11),item(tool3,141,12),item(tool4,39,20),item(tool5,133,9),item(tool6,132,13),item(tool7,53,19)]), entity(agentA8,A,19.30023,-99.19738,motorcycle), dump(dump6,19.37424,-99.09267), workshop(workshop8,19.41512,-99.01923), charge(250), shop(shop3,19.33139,-99.00328,1,[item(item0,70,20),item(tool0,91,9),item(tool7,42,10)]), dump(dump3,19.31904,-99.01868), workshop(workshop2,19.33312,-99.08554), storage(storage9,19.41272,-99.15535,9557,0,[]), storage(storage4,19.36119,-99.17035,8040,0,[]), workshop(workshop4,19.37509,-99.05729), lat(19.38689), shop(shop6,19.39694,-99.1675,5,[item(item1,79,15),item(item2,62,14),item(item5,78,10),item(item7,16,17),item(tool4,39,18)]), entity(agentA2,A,19.38689,-99.17834,drone), shop(shop5,19.37946,-99.07389,2,[item(item1,103,15),item(item4,99,9),item(item7,17,13),item(tool1,89,11),item(tool4,37,17),item(tool5,103,7),item(tool6,129,11)]), chargingStation(chargingStation13,19.38638,-99.02568,79), entity(agentA16,A,19.31248,-99.0403,car), entity(agentA6,A,19.30774,-99.01944,motorcycle), money(50000), entity(agentA15,A,19.30406,-99.10986,car), chargingStation(chargingStation16,19.4328,-99.03119,89), storage(storage15,19.43708,-99.0397,14486,0,[]), deadline(1514672810536), routeLength(0), entity(agentA28,A,19.30451,-99.04253,truck), dump(dump1,19.3315,-99.10955), workshop(workshop1,19.33872,-99.15421), workshop(workshop0,19.33281,-99.1987), dump(dump4,19.34984,-99.19905), shop(shop11,19.42324,-99.19889,4,[item(item1,98,8),item(item3,101,12),item(item4,104,9),item(item6,97,14),item(tool1,87,15)]), load(0), chargingStation(chargingStation6,19.35604,-99.12279,120), chargingStation(chargingStation14,19.447,-99.1726,51)]}
					// percepts Collection<Percept>>: [item(item4,41,tools([]),parts([])), simStart, item(item2,44,tools([]),parts([])), maxLat(19.45), item(item0,21,tools([]),parts([])), item(tool2,33,tools([]),parts([])), team(A), item(tool6,38,tools([]),parts([])), item(item14,354,tools([tool4,tool2]),parts([[item3,3],[item13,1],[item9,1]])), role(drone,5,100,250,[tool4,tool6,tool7]), item(tool0,35,tools([]),parts([])), minLat(19.3), item(item12,64,tools([tool7,tool5]),parts([[item7,1],[item11,1]])), item(item8,94,tools([tool1,tool5]),parts([[item7,3],[item0,1],[item4,1]])), item(item9,126,tools([tool1]),parts([[item2,3],[item6,1]])), item(tool4,47,tools([]),parts([])), item(item5,42,tools([]),parts([])), item(item6,15,tools([]),parts([])), item(item1,43,tools([]),parts([])), item(tool5,34,tools([]),parts([])), item(tool1,28,tools([]),parts([])), id(2017-Mexico-City-Test), steps(1000), map(mexico-city), item(item11,60,tools([tool3]),parts([[item7,2],[item6,1]])), item(tool3,37,tools([]),parts([])), item(item10,166,tools([]),parts([[item0,3],[item4,3],[item6,1]])), item(item7,30,tools([]),parts([])), item(tool7,48,tools([]),parts([])), seedCapital(50000), minLon(-99.2), maxLon(-99.0), item(item13,270,tools([tool1]),parts([[item4,1],[item8,3],[item2,1]])), item(item3,36,tools([]),parts([])), storage(storage13,19.44019,-99.18794,14889,0,[]), storage(storage7,19.35245,-99.04573,13230,0,[]), storage(storage14,19.42892,-99.10555,8183,0,[]), timestamp(1514672806565), route([]), shop(shop4,19.35746,-99.19067,5,[item(item0,74,20),item(item1,84,11),item(item2,84,7),item(item5,63,19),item(item6,98,17),item(item7,19,14)]), dump(dump8,19.39958,-99.13238), chargingStation(chargingStation15,19.42892,-99.11276,107), workshop(workshop6,19.40399,-99.18714), shop(shop10,19.39051,-99.03542,4,[item(item1,86,7),item(item2,81,12),item(item3,122,12),item(item5,69,6),item(item7,14,16),item(tool2,45,16),item(tool4,47,11),item(tool6,124,17),item(tool7,48,8)]), entity(agentA5,A,19.40736,-99.05846,motorcycle), workshop(workshop5,19.35316,-99.03779), dump(dump9,19.41991,-99.07416), entity(agentA7,A,19.33828,-99.12541,motorcycle), shop(shop1,19.32016,-99.12328,3,[item(item1,91,18),item(tool0,93,10),item(tool1,72,16),item(tool5,107,9),item(tool6,138,9),item(tool7,39,6)]), lastActionResult(successful), chargingStation(chargingStation1,19.30823,-99.14639,123), entity(agentA19,A,19.37567,-99.11684,car), chargingStation(chargingStation3,19.30137,-99.04509,91), workshop(workshop7,19.39895,-99.0919), entity(agentA25,A,19.36242,-99.02579,truck), chargingStation(chargingStation12,19.3876,-99.07765,128), storage(storage2,19.32609,-99.09198,12589,0,[]), dump(dump13,19.4271,-99.03601), shop(shop0,19.33569,-99.16989,1,[item(item4,101,13),item(tool0,84,20),item(tool3,126,18),item(tool5,108,16),item(tool6,101,12)]), workshop(workshop9,19.44614,-99.19569), chargingStation(chargingStation4,19.30961,-99.03329,119), storage(storage12,19.39664,-99.03379,9594,0,[]), workshop(workshop10,19.44087,-99.14081), step(0), entity(agentA4,A,19.43752,-99.08263,drone), entity(agentA27,A,19.33246,-99.10792,truck), lastActionParams([]), chargingStation(chargingStation5,19.35958,-99.1865,73), dump(dump7,19.36426,-99.03392), storage(storage0,19.32686,-99.19329,9604,0,[]), entity(agentA24,A,19.37424,-99.05352,truck), entity(agentA17,A,19.37227,-99.13973,car), dump(dump0,19.33927,-99.18741), chargingStation(chargingStation2,19.33813,-99.08956,98), facility(), entity(agentA21,A,19.3971,-99.05624,truck), chargingStation(chargingStation9,19.35086,-99.0163,53), lastAction(noAction), entity(agentA18,A,19.39969,-99.02349,car), shop(shop2,19.32144,-99.0697,3,[item(item0,90,14),item(item6,91,10),item(tool5,133,19)]), workshop(workshop3,19.37344,-99.09335), shop(shop13,19.44068,-99.1147,5,[item(item5,69,6),item(tool0,69,19),item(tool1,85,20)]), storage(storage6,19.3626,-99.11757,13702,0,[]), chargingStation(chargingStation0,19.31722,-99.18127,140), dump(dump10,19.38139,-99.02397), entity(agentA12,A,19.33519,-99.09793,motorcycle), entity(agentA20,A,19.40171,-99.19236,car), storage(storage1,19.30076,-99.12679,7824,0,[]), entity(agentA3,A,19.40928,-99.11384,drone), dump(dump5,19.34982,-99.14985), shop(shop9,19.39585,-99.04156,1,[item(item0,70,18),item(item3,95,9),item(item4,141,20),item(item7,16,6),item(tool4,37,20),item(tool5,121,17),item(tool6,120,8),item(tool7,45,9)]), chargingStation(chargingStation7,19.37113,-99.11836,54), storage(storage5,19.36626,-99.12744,11163,0,[]), chargingStation(chargingStation8,19.3591,-99.05357,111), entity(agentA1,A,19.37562,-99.00317,drone), chargingStation(chargingStation11,19.41131,-99.14265,130), storage(storage8,19.3902,-99.18367,12169,0,[]), lon(-99.17834), shop(shop14,19.42382,-99.03512,3,[item(item1,99,17),item(item3,105,9),item(item4,139,19),item(item7,14,20),item(tool0,72,13),item(tool4,36,15),item(tool6,97,19)]), entity(agentA13,A,19.43401,-99.06124,car), chargingStation(chargingStation10,19.38384,-99.17284,122), dump(dump11,19.42418,-99.17356), workshop(workshop11,19.43077,-99.02892), storage(storage11,19.41385,-99.05545,13467,0,[]), entity(agentA23,A,19.44255,-99.15922,truck), shop(shop12,19.43897,-99.14012,2,[item(item1,82,10),item(tool2,56,15),item(tool3,118,19)]), entity(agentA9,A,19.32065,-99.13607,motorcycle), entity(agentA26,A,19.38986,-99.14356,truck), storage(storage10,19.40745,-99.10503,11491,0,[]), entity(agentA10,A,19.3473,-99.19299,motorcycle), actionID(0), requestAction, storage(storage3,19.30459,-99.01727,14934,0,[]), shop(shop7,19.39279,-99.1337,5,[item(item0,67,17),item(item1,92,13),item(item2,87,5),item(tool0,68,11),item(tool7,47,17)]), entity(agentA14,A,19.44007,-99.14925,car), entity(agentA11,A,19.44882,-99.19551,motorcycle), entity(agentA22,A,19.33237,-99.02805,truck), dump(dump2,19.31402,-99.05739), dump(dump12,19.44191,-99.08681), shop(shop8,19.38367,-99.10324,3,[item(item2,84,7),item(item4,144,16),item(item7,17,8),item(tool1,82,11),item(tool3,141,12),item(tool4,39,20),item(tool5,133,9),item(tool6,132,13),item(tool7,53,19)]), entity(agentA8,A,19.30023,-99.19738,motorcycle), dump(dump6,19.37424,-99.09267), workshop(workshop8,19.41512,-99.01923), charge(250), shop(shop3,19.33139,-99.00328,1,[item(item0,70,20),item(tool0,91,9),item(tool7,42,10)]), dump(dump3,19.31904,-99.01868), workshop(workshop2,19.33312,-99.08554), storage(storage9,19.41272,-99.15535,9557,0,[]), storage(storage4,19.36119,-99.17035,8040,0,[]), workshop(workshop4,19.37509,-99.05729), lat(19.38689), shop(shop6,19.39694,-99.1675,5,[item(item1,79,15),item(item2,62,14),item(item5,78,10),item(item7,16,17),item(tool4,39,18)]), entity(agentA2,A,19.38689,-99.17834,drone), shop(shop5,19.37946,-99.07389,2,[item(item1,103,15),item(item4,99,9),item(item7,17,13),item(tool1,89,11),item(tool4,37,17),item(tool5,103,7),item(tool6,129,11)]), chargingStation(chargingStation13,19.38638,-99.02568,79), entity(agentA16,A,19.31248,-99.0403,car), entity(agentA6,A,19.30774,-99.01944,motorcycle), money(50000), entity(agentA15,A,19.30406,-99.10986,car), chargingStation(chargingStation16,19.4328,-99.03119,89), storage(storage15,19.43708,-99.0397,14486,0,[]), deadline(1514672810536), routeLength(0), entity(agentA28,A,19.30451,-99.04253,truck), dump(dump1,19.3315,-99.10955), workshop(workshop1,19.33872,-99.15421), workshop(workshop0,19.33281,-99.1987), dump(dump4,19.34984,-99.19905), shop(shop11,19.42324,-99.19889,4,[item(item1,98,8),item(item3,101,12),item(item4,104,9),item(item6,97,14),item(tool1,87,15)]), load(0), chargingStation(chargingStation6,19.35604,-99.12279,120), chargingStation(chargingStation14,19.447,-99.1726,51)]
					// playerName: agentA2 (of entity connectoinA2)
					//
					// allPercept will have mappings from entity (of the playerName) to Collection<Percept>
					// 		a percept is just one bit of info as an atom, like map(mexico), route([..]), item(...), or shop(....)
					// Since a player is of one entity type only, we just care about the first (and only) mapping
					// which we store in percepts (via get(0)). So percept is Collection<value>
//					val allPercepts : Map<String, Collection<Percept>> = MT_senseAllPlayerPercepts(playerName) // This is blocking!
//					val entityType = allPercepts.keySet().get(0)	// we only gather the first map as agents are of 1 entity only
					// val percepts = allPercepts.get(entityType)
//					info("Player agent {0} (of entity type {3}) received {1} percepts (type: {2})", playerName,
//						Util.getNoOfPercepts(percepts), Util.getTypePercept(percepts), entityType)

					// Then, allPercept.value() will yield a collection of the values: Collection<Collection<Percept>>
					// var percepts = allPercepts.values().get(0) // this will get the first collection (of percepts)

					// TODO: More compact but complains "percepts cannot be resolved to a type": SARL compilation issue?
					// Collapses all sensors for the agent (who may be associated with many entities) into one list of Percept
					// var percepts : List<Percept> = new ArrayList<Percept>
					// allPercepts.values().forEach[percepts::addAll]	// works even if an agent is mapped to many entities


					// Now the simplest way, just give me the percepts of player (assuming player is of 1 entity)
					// The percepts will also include all the simStart information, even if we are on requestAction message
					// I think the EIS was done to do that, so agents can re-start if necessary and have all sim info in next percept
					val percepts : Collection<Percept> = MT_sensePlayerPercepts(playerName) // This is blocking!
					val myServerName = Util.getAgentName(percepts)
			
					info("EI Player {0} (game entity name {3}) has RECEIVED {1} PERCEPTS (type: {2})", 
						playerName, Util.getNoOfPercepts(percepts), Util.getTypePercept(percepts), myServerName)
                    
					// Populate general data (all entities, team, simstart) static buffers
					Util.populateDataBuffers(percepts)				 	
					// SELF:
					//	Add the action results of playerName(self) to percept aggregator
					//	Add an the agent state for the playerNamein the aggregator (contains location, items holding, etc)
					aggregator.addActionResults(playerName, percepts)
					
					var PlayerState = PlayerStateBuilder.build(myServerName, percepts) // build a new agent state from percept
					aggregator.addPlayerTeam(playerName, PlayerState) // Fill the aggregator with this agent state for playerName
					
					// OTHER ENTITIES: 
                    //	Add to aggregator the info of all other entities that are not part of the team (not agents)
                    aggregator.addPlayerOpposition()

					// FACILITIES: Aggregate all facilities information 
					// (shop, workshops, charging stations, dump, storage, resourceNodes)
					aggregator.addFacilities(percepts)

					// JOBS: Aggregate all jobs (job, auction, mission, or posted)
					aggregator.addJobs(percepts)
					
				} catch (e : PerceiveException) {
					agent_says("There was an exception perceiving for player {0}: {1}", playerName, e.message)
				} catch (e : Exception) {
					error("Something bad has happened during perception for player {0}: {1}", playerName, e.toString)
				}
            ])

			// If you want to debug the charging stations seen across all agents.
			//
			// System.out.println("##########################################################")
			// System.out.println(aggregator.chargingStations)
			// System.out.println(aggregator.chargingStations.size())
			// System.out.println("##########################################################")
            
            
			// Once aggregator has been filled with what was perceived, process it to emit events
			// By doing this, shared same information across players (e.g., charging stations) is handled once
			process_aggregator(aggregator)

			// This will print always but maybe should be done just once at the start!
			if (SimStartBuffer.mapName !== null) {
				agent_says("I am playing in map {0}", SimStartBuffer.mapName)
			} else {
				agent_says("I still don't know which map I am playing....")
			}
		]
	}
	
	
	// Given a perception aggregator, process it by emitting corresponding events
	def process_aggregator(aggregator : PerceptAggregator) {
		//////////////////////////////////////////////////////////////////////////
		// At this point **aggregator **has all the sensing from all the agents
		// Next, Coordinator will emit events per sensing data separately. All agents in the simulation will receive that.
		// Check current issue (Dec 2017) on SARL dropping some of these events:
		// https://github.com/sarl/sarl/issues/713#issuecomment-322680153


		// Emit SARL events for each TEAM percept (now just the money)
		var allEntityPercepts = new HashSet<E_TellEntityInfo>()
		allEntityPercepts.addAll(aggregator.getTeamMemberPercepts())
		allEntityPercepts.addAll(aggregator.getGameEntityPercepts())
		agent_says("Emitting {0} event percepts about {1}", allEntityPercepts.length, "ENTITIES")
		for (e : allEntityPercepts) {
			emit(e)
		}

		// Emit SARL events for each ACTION RESULT (of every agent as they all have been aggregated)
		var actionPercepts = aggregator.getActionPercepts();
		agent_says("Emitting {0} event percepts about {1}", actionPercepts.length, "RESULT OF ACTIONS")
		for (e : actionPercepts) {
			emit(e);
		}

		// Emit SARL events for all perception about FACILITIES (shops, charging stations, workshops, dumps, storage, resources)
		var allFacilityPercepts = new ArrayList<E_FacilityInfo>()
		allFacilityPercepts.addAll(aggregator.shopSensedPercepts)
		allFacilityPercepts.addAll(aggregator.chargingStationSensedPercepts)
		allFacilityPercepts.addAll(aggregator.workshopSensedPercepts)
		allFacilityPercepts.addAll(aggregator.dumpSensedPercepts)
		allFacilityPercepts.addAll(aggregator.storageSensedPercepts)
		allFacilityPercepts.addAll(aggregator.resourceSensedPercepts)
		agent_says("Emitting {0} event percepts about {1}", allFacilityPercepts.length, "FACILITIES")
		for (e : allFacilityPercepts) {
			emit(e)
		}

		// Emit SARL events for all perception about JOBS (regular, auctions, team jobs, missions)
		var allJobPercepts = new ArrayList<E_JobInfo>()
		allJobPercepts.addAll(aggregator.regularJobEvents)
		allJobPercepts.addAll(aggregator.auctionJobPercepts)

		agent_says("Emitting {0} event percepts about {1}", allJobPercepts.length, "JOBS")
		for (e : allJobPercepts) {
			emit(e)
		}
	}

	/** 
	 * Receives a constrained action from an agent. 
	 * Once the constraints are met the communicator will pass the action to the server. 
	 */
    on E_AgentAction [occurrence.constraints !== null] {
		// TODO: factor in constraints once constraints are met
		performAction(occurrence.playerName, occurrence.action)
	}
	/** 
	 * Used to receive a unconstrained action.
	 * Once an unconstrained action has been received from an agent the communicator will communicate it with the server
	 * 
	 */
	on E_AgentAction [occurrence.constraints === null] {
        performAction(occurrence.playerName, occurrence.action)
	}
	/** 
	 * A basic method for sending actions the the EIS server
	 * If sending fails, the exception is caught and logged. 
	 */
	def performAction(playerName: String, action : Action) {
        debug("Performing action {1} for player {0}", playerName, action.toProlog())
		try {
			// perform the action by playerNamein the EIS
            MT_executeAction(playerName, action);
		} catch (e : ActException) {
            if (action !== null)
				warning("Could not perform action " + action + " for " + playerName);
		}
	}

	on E_WorkshopInfo {
		agent_says("I have seen a workshop named {0}", occurrence.workshop.name)
	}




}
