/** 
 * SARL-MASSIM - Interface between the SARL agent-oriented language 
 * and the MASSIM 2017 server
 * Copyright (C) 2017 The SARL-MASSIM Authors.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package au.edu.rmit.agtgrp.agtcity.sarl.mw.agents.scheduler

import eis.EnvironmentInterfaceStandard
import eis.exceptions.ActException
import eis.exceptions.AgentException
import eis.exceptions.ManagementException
import eis.iilang.EnvironmentState;
import eis.iilang.Percept
import eis.iilang.Action
import eis.iilang.Percept

import massim.eismassim.EnvironmentInterface

import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.Schedules

import org.json.JSONObject
import java.io.File
import java.nio.file.Paths
//import java.nio.file.Path
//import java.io.IOException
//import java.nio.file.Files
//import java.nio.file.Paths
//import javax.management.relation.RelationException
import java.util.List
import java.util.Collection
import java.util.Map
import java.util.ArrayList

import au.edu.rmit.agtgrp.agtcity.sarl.mw.capacities.C_Reporting
import au.edu.rmit.agtgrp.agtcity.sarl.mw.capacities.C_MassimTalking
import au.edu.rmit.agtgrp.agtcity.sarl.mw.skills.S_ConsoleReporting
import au.edu.rmit.agtgrp.agtcity.sarl.mw.skills.S_MassimTalking17

import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.E_AgentAction

import au.edu.rmit.agtgrp.agtcity.sarl.mw.utils.ConfHandler
import au.edu.rmit.agtgrp.agtcity.sarl.mw.aggregator.PerceptAggregator
import au.edu.rmit.agtgrp.agtcity.sarl.mw.aggregator.PlayerStateBuilder
import au.edu.rmit.agtgrp.agtcity.sarl.mw.aggregator.Util
import au.edu.rmit.agtgrp.agtcity.sarl.mw.aggregator.SimStartBuffer
import eis.iilang.IILVisitor
import io.sarl.core.AgentSpawned
import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.E_SenseEnvironment
import java.util.HashMap
import java.util.UUID
import java.util.Set
import java.util.HashSet
import eis.exceptions.PerceiveException
import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.EntityPercept
import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.FacilitySensedPercept
import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.JobPercept
import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.WorkshopSensedPercept

/** 
 * @author Sebastian Sardina (ssardina@gmail.com)
 * 
 */
agent SchedulerAgent {
    uses Logging, DefaultContextInteractions
	uses Lifecycle
	uses C_Reporting, C_MassimTalking
	uses Schedules

	val myName = "Scheduler-Agent"

    var ei : EnvironmentInterfaceStandard // the handler to the interface
	
	// These are the connection players we will control
	var myConnections = #["connectionA1", "connectionA2", "connectionA3", "connectionA4", "connectionA5",
		"connectionA6"]
    

	var agents : Map<String, UUID> = new HashMap<String, UUID>() // map game player --> UUID of SARL agent
	var agentsPendingToInitialize : Set<UUID> = new HashSet<UUID>() 	// set of all SARL agents in the system

	// To keep track of agents spawned succesfully
	var noToSpawn : int = 0 // number of agents to be spawn in total
	var noSpawn : int = 0 // number of agents already spawn successfully and alive!
	val noSpawn_lock : Object = new Object()

    on Initialize {
		val eiMassimConfigFile = "eismassimconfig.json"
		val eiAgentConfigFile = "agentsconfig.json"

		var args = newArrayList(occurrence.parameters)
        var eiConfigDir : String = ""

		// Give reporting skill via console
		setSkill(new S_ConsoleReporting("Scheduler Agent"), C_Reporting)
		// 4 - debug, 3 - INFO, 2 - WARNING
		setLogLevel(3)
		
		info("PHASE 1: INSTANTIATING SKILL TO COMMUNICATE WITH GAME SERVER")
        // get the directory for the config files (server + players) if not part of the parameters
        if (args.length != 0)
            eiConfigDir = args.get(0) as String
        else {
            info("PHASE 1.2: CHOOSE CONFIGURATION")
            eiConfigDir = ConfHandler.getConfDir()
        }
		debug("Configuration settings: 
				\t My SARL agent name: {0}
				\t Directory of configuration files: {1}
				\t File containing authentication and sever info: {2}", myName, eiConfigDir, eiMassimConfigFile)

		// Give agent ability to talk to MASSIM server
		setSkill(new S_MassimTalking17(Paths.get(eiConfigDir, eiMassimConfigFile)), C_MassimTalking)

		agent_says("PHASE 2: INITIALIZING EI WITH FILE {0} TO CONTROL CONNECTIONS: {1} ", eiMassimConfigFile,
			myConnections.toString)
		myConnections.forEach( [player : String|MT_addPlayerByName(player)]) // entities to control
		// this creates the EI and starts it, and authenticates all entities to server (may take time)
		if (MT_initialize()) { 
			agent_says("The EI is now initialized, entities are being authenticated...")
		} else {
			agent_says("Something wrong when initializing the EI")
			killMe
		}

		in(2000) [
			info("PHASE 3: SPAWNING WORKER SARL AGENTS FOR EACH PLAYER")
			noToSpawn = MT_getPlayersNames().size	// we will spawn this number of SARL agents
			MT_getPlayersNames().forEach [ playerName : String |
				synchronized (agentsPendingToInitialize) {
					val UUID = spawn(DummyAgent, playerName) // Spawn a dummy agent called playerName
					agent_says("A SARL agent {0} has been SPAWN to control game player {1}", UUID.toString, playerName)
					agents.put(playerName, UUID);
					agentsPendingToInitialize.add(UUID)
				}
			]
		]
	} // INITIALIZE


	// Report that a dummy agent (not myself!) has born
	// Be careful: occurrence.fromMe is true IFF I was the one show spawned the agent (not emmitted the event!)
	// check issue bug: https://github.com/sarl/sarl/issues/849
	on AgentSpawned [!(occurrence.agentIdentifiers.get(0) == this.ID)] {
		val agent_UUID = occurrence.agentIdentifiers.get(0)
		val agent_type = occurrence.agentType

		debug("An Agent {0} (of type: {1}) has finished spawning", agent_UUID, agent_type)
		synchronized (agentsPendingToInitialize) {
			if (agentsPendingToInitialize.remove(agent_UUID)) {
				noSpawn = noSpawn + 1
				agent_says("Agent {0} (no. {1}; type: {2}) has been created successfully and is now alive!", agent_UUID,
					noSpawn, agent_type)
				debug("Total agents to be spawn: {0} - Agents spawn already: {1}", noToSpawn, noSpawn)

				// No more to agents to wait, start sensing!
				if (agentsPendingToInitialize.empty && noSpawn == noToSpawn) {
					agent_shouts("All {0} agent-players have been created, now starting to sense and act....", noSpawn)
					info("PHASE 4: ALL INITIALIZED, READY TO GO!!!!!!!!!")
					emit(new E_SenseEnvironment())
				} 
			} else {
				warning("Strange, an agent {0} has spawned but I was not waiting for it....", agent_UUID, agent_type)
			}
		
		}
	}









	on E_SenseEnvironment {
		// Initializes to empty three static data buffers for entities, sim-start and
		if (Util.initDataBuffers()) {}
		
		// This is done every 1000ms
		every(1000)[
			var aggregator = new PerceptAggregator(); // collect all the percepts from all agents
			// ////////////////////////////////////////////////////////////////////////
            // First all sensing is aggregated into *aggregator* object for removing redundant sensing across agents
            agents.keySet.forEach([ playerName: String |
				try {
					// First get the percepts of playerName
					// https://github.com/agentcontest/massim/blob/master/docs/scenario.md#percepts
					// https://github.com/agentcontest/massim/blob/master/docs/eismassim.md
					//
					agent_says("Getting percepts (blocking) for player *{0}*", playerName)

					// PLAYER SENSING EXAMPLE GETTING ALL PERCEPTS FOR ALL PLAYER TYPE OF ENTITY (USUALLY JUST 1):
					//
					// allPercepts Map<String, Collection<Percept>>: {connectionA2=[item(item4,41,tools([]),parts([])), simStart, item(item2,44,tools([]),parts([])), maxLat(19.45), item(item0,21,tools([]),parts([])), item(tool2,33,tools([]),parts([])), team(A), item(tool6,38,tools([]),parts([])), item(item14,354,tools([tool4,tool2]),parts([[item3,3],[item13,1],[item9,1]])), role(drone,5,100,250,[tool4,tool6,tool7]), item(tool0,35,tools([]),parts([])), minLat(19.3), item(item12,64,tools([tool7,tool5]),parts([[item7,1],[item11,1]])), item(item8,94,tools([tool1,tool5]),parts([[item7,3],[item0,1],[item4,1]])), item(item9,126,tools([tool1]),parts([[item2,3],[item6,1]])), item(tool4,47,tools([]),parts([])), item(item5,42,tools([]),parts([])), item(item6,15,tools([]),parts([])), item(item1,43,tools([]),parts([])), item(tool5,34,tools([]),parts([])), item(tool1,28,tools([]),parts([])), id(2017-Mexico-City-Test), steps(1000), map(mexico-city), item(item11,60,tools([tool3]),parts([[item7,2],[item6,1]])), item(tool3,37,tools([]),parts([])), item(item10,166,tools([]),parts([[item0,3],[item4,3],[item6,1]])), item(item7,30,tools([]),parts([])), item(tool7,48,tools([]),parts([])), seedCapital(50000), minLon(-99.2), maxLon(-99.0), item(item13,270,tools([tool1]),parts([[item4,1],[item8,3],[item2,1]])), item(item3,36,tools([]),parts([])), storage(storage13,19.44019,-99.18794,14889,0,[]), storage(storage7,19.35245,-99.04573,13230,0,[]), storage(storage14,19.42892,-99.10555,8183,0,[]), timestamp(1514672806565), route([]), shop(shop4,19.35746,-99.19067,5,[item(item0,74,20),item(item1,84,11),item(item2,84,7),item(item5,63,19),item(item6,98,17),item(item7,19,14)]), dump(dump8,19.39958,-99.13238), chargingStation(chargingStation15,19.42892,-99.11276,107), workshop(workshop6,19.40399,-99.18714), shop(shop10,19.39051,-99.03542,4,[item(item1,86,7),item(item2,81,12),item(item3,122,12),item(item5,69,6),item(item7,14,16),item(tool2,45,16),item(tool4,47,11),item(tool6,124,17),item(tool7,48,8)]), entity(agentA5,A,19.40736,-99.05846,motorcycle), workshop(workshop5,19.35316,-99.03779), dump(dump9,19.41991,-99.07416), entity(agentA7,A,19.33828,-99.12541,motorcycle), shop(shop1,19.32016,-99.12328,3,[item(item1,91,18),item(tool0,93,10),item(tool1,72,16),item(tool5,107,9),item(tool6,138,9),item(tool7,39,6)]), lastActionResult(successful), chargingStation(chargingStation1,19.30823,-99.14639,123), entity(agentA19,A,19.37567,-99.11684,car), chargingStation(chargingStation3,19.30137,-99.04509,91), workshop(workshop7,19.39895,-99.0919), entity(agentA25,A,19.36242,-99.02579,truck), chargingStation(chargingStation12,19.3876,-99.07765,128), storage(storage2,19.32609,-99.09198,12589,0,[]), dump(dump13,19.4271,-99.03601), shop(shop0,19.33569,-99.16989,1,[item(item4,101,13),item(tool0,84,20),item(tool3,126,18),item(tool5,108,16),item(tool6,101,12)]), workshop(workshop9,19.44614,-99.19569), chargingStation(chargingStation4,19.30961,-99.03329,119), storage(storage12,19.39664,-99.03379,9594,0,[]), workshop(workshop10,19.44087,-99.14081), step(0), entity(agentA4,A,19.43752,-99.08263,drone), entity(agentA27,A,19.33246,-99.10792,truck), lastActionParams([]), chargingStation(chargingStation5,19.35958,-99.1865,73), dump(dump7,19.36426,-99.03392), storage(storage0,19.32686,-99.19329,9604,0,[]), entity(agentA24,A,19.37424,-99.05352,truck), entity(agentA17,A,19.37227,-99.13973,car), dump(dump0,19.33927,-99.18741), chargingStation(chargingStation2,19.33813,-99.08956,98), facility(), entity(agentA21,A,19.3971,-99.05624,truck), chargingStation(chargingStation9,19.35086,-99.0163,53), lastAction(noAction), entity(agentA18,A,19.39969,-99.02349,car), shop(shop2,19.32144,-99.0697,3,[item(item0,90,14),item(item6,91,10),item(tool5,133,19)]), workshop(workshop3,19.37344,-99.09335), shop(shop13,19.44068,-99.1147,5,[item(item5,69,6),item(tool0,69,19),item(tool1,85,20)]), storage(storage6,19.3626,-99.11757,13702,0,[]), chargingStation(chargingStation0,19.31722,-99.18127,140), dump(dump10,19.38139,-99.02397), entity(agentA12,A,19.33519,-99.09793,motorcycle), entity(agentA20,A,19.40171,-99.19236,car), storage(storage1,19.30076,-99.12679,7824,0,[]), entity(agentA3,A,19.40928,-99.11384,drone), dump(dump5,19.34982,-99.14985), shop(shop9,19.39585,-99.04156,1,[item(item0,70,18),item(item3,95,9),item(item4,141,20),item(item7,16,6),item(tool4,37,20),item(tool5,121,17),item(tool6,120,8),item(tool7,45,9)]), chargingStation(chargingStation7,19.37113,-99.11836,54), storage(storage5,19.36626,-99.12744,11163,0,[]), chargingStation(chargingStation8,19.3591,-99.05357,111), entity(agentA1,A,19.37562,-99.00317,drone), chargingStation(chargingStation11,19.41131,-99.14265,130), storage(storage8,19.3902,-99.18367,12169,0,[]), lon(-99.17834), shop(shop14,19.42382,-99.03512,3,[item(item1,99,17),item(item3,105,9),item(item4,139,19),item(item7,14,20),item(tool0,72,13),item(tool4,36,15),item(tool6,97,19)]), entity(agentA13,A,19.43401,-99.06124,car), chargingStation(chargingStation10,19.38384,-99.17284,122), dump(dump11,19.42418,-99.17356), workshop(workshop11,19.43077,-99.02892), storage(storage11,19.41385,-99.05545,13467,0,[]), entity(agentA23,A,19.44255,-99.15922,truck), shop(shop12,19.43897,-99.14012,2,[item(item1,82,10),item(tool2,56,15),item(tool3,118,19)]), entity(agentA9,A,19.32065,-99.13607,motorcycle), entity(agentA26,A,19.38986,-99.14356,truck), storage(storage10,19.40745,-99.10503,11491,0,[]), entity(agentA10,A,19.3473,-99.19299,motorcycle), actionID(0), requestAction, storage(storage3,19.30459,-99.01727,14934,0,[]), shop(shop7,19.39279,-99.1337,5,[item(item0,67,17),item(item1,92,13),item(item2,87,5),item(tool0,68,11),item(tool7,47,17)]), entity(agentA14,A,19.44007,-99.14925,car), entity(agentA11,A,19.44882,-99.19551,motorcycle), entity(agentA22,A,19.33237,-99.02805,truck), dump(dump2,19.31402,-99.05739), dump(dump12,19.44191,-99.08681), shop(shop8,19.38367,-99.10324,3,[item(item2,84,7),item(item4,144,16),item(item7,17,8),item(tool1,82,11),item(tool3,141,12),item(tool4,39,20),item(tool5,133,9),item(tool6,132,13),item(tool7,53,19)]), entity(agentA8,A,19.30023,-99.19738,motorcycle), dump(dump6,19.37424,-99.09267), workshop(workshop8,19.41512,-99.01923), charge(250), shop(shop3,19.33139,-99.00328,1,[item(item0,70,20),item(tool0,91,9),item(tool7,42,10)]), dump(dump3,19.31904,-99.01868), workshop(workshop2,19.33312,-99.08554), storage(storage9,19.41272,-99.15535,9557,0,[]), storage(storage4,19.36119,-99.17035,8040,0,[]), workshop(workshop4,19.37509,-99.05729), lat(19.38689), shop(shop6,19.39694,-99.1675,5,[item(item1,79,15),item(item2,62,14),item(item5,78,10),item(item7,16,17),item(tool4,39,18)]), entity(agentA2,A,19.38689,-99.17834,drone), shop(shop5,19.37946,-99.07389,2,[item(item1,103,15),item(item4,99,9),item(item7,17,13),item(tool1,89,11),item(tool4,37,17),item(tool5,103,7),item(tool6,129,11)]), chargingStation(chargingStation13,19.38638,-99.02568,79), entity(agentA16,A,19.31248,-99.0403,car), entity(agentA6,A,19.30774,-99.01944,motorcycle), money(50000), entity(agentA15,A,19.30406,-99.10986,car), chargingStation(chargingStation16,19.4328,-99.03119,89), storage(storage15,19.43708,-99.0397,14486,0,[]), deadline(1514672810536), routeLength(0), entity(agentA28,A,19.30451,-99.04253,truck), dump(dump1,19.3315,-99.10955), workshop(workshop1,19.33872,-99.15421), workshop(workshop0,19.33281,-99.1987), dump(dump4,19.34984,-99.19905), shop(shop11,19.42324,-99.19889,4,[item(item1,98,8),item(item3,101,12),item(item4,104,9),item(item6,97,14),item(tool1,87,15)]), load(0), chargingStation(chargingStation6,19.35604,-99.12279,120), chargingStation(chargingStation14,19.447,-99.1726,51)]}
					// percepts Collection<Percept>>: [item(item4,41,tools([]),parts([])), simStart, item(item2,44,tools([]),parts([])), maxLat(19.45), item(item0,21,tools([]),parts([])), item(tool2,33,tools([]),parts([])), team(A), item(tool6,38,tools([]),parts([])), item(item14,354,tools([tool4,tool2]),parts([[item3,3],[item13,1],[item9,1]])), role(drone,5,100,250,[tool4,tool6,tool7]), item(tool0,35,tools([]),parts([])), minLat(19.3), item(item12,64,tools([tool7,tool5]),parts([[item7,1],[item11,1]])), item(item8,94,tools([tool1,tool5]),parts([[item7,3],[item0,1],[item4,1]])), item(item9,126,tools([tool1]),parts([[item2,3],[item6,1]])), item(tool4,47,tools([]),parts([])), item(item5,42,tools([]),parts([])), item(item6,15,tools([]),parts([])), item(item1,43,tools([]),parts([])), item(tool5,34,tools([]),parts([])), item(tool1,28,tools([]),parts([])), id(2017-Mexico-City-Test), steps(1000), map(mexico-city), item(item11,60,tools([tool3]),parts([[item7,2],[item6,1]])), item(tool3,37,tools([]),parts([])), item(item10,166,tools([]),parts([[item0,3],[item4,3],[item6,1]])), item(item7,30,tools([]),parts([])), item(tool7,48,tools([]),parts([])), seedCapital(50000), minLon(-99.2), maxLon(-99.0), item(item13,270,tools([tool1]),parts([[item4,1],[item8,3],[item2,1]])), item(item3,36,tools([]),parts([])), storage(storage13,19.44019,-99.18794,14889,0,[]), storage(storage7,19.35245,-99.04573,13230,0,[]), storage(storage14,19.42892,-99.10555,8183,0,[]), timestamp(1514672806565), route([]), shop(shop4,19.35746,-99.19067,5,[item(item0,74,20),item(item1,84,11),item(item2,84,7),item(item5,63,19),item(item6,98,17),item(item7,19,14)]), dump(dump8,19.39958,-99.13238), chargingStation(chargingStation15,19.42892,-99.11276,107), workshop(workshop6,19.40399,-99.18714), shop(shop10,19.39051,-99.03542,4,[item(item1,86,7),item(item2,81,12),item(item3,122,12),item(item5,69,6),item(item7,14,16),item(tool2,45,16),item(tool4,47,11),item(tool6,124,17),item(tool7,48,8)]), entity(agentA5,A,19.40736,-99.05846,motorcycle), workshop(workshop5,19.35316,-99.03779), dump(dump9,19.41991,-99.07416), entity(agentA7,A,19.33828,-99.12541,motorcycle), shop(shop1,19.32016,-99.12328,3,[item(item1,91,18),item(tool0,93,10),item(tool1,72,16),item(tool5,107,9),item(tool6,138,9),item(tool7,39,6)]), lastActionResult(successful), chargingStation(chargingStation1,19.30823,-99.14639,123), entity(agentA19,A,19.37567,-99.11684,car), chargingStation(chargingStation3,19.30137,-99.04509,91), workshop(workshop7,19.39895,-99.0919), entity(agentA25,A,19.36242,-99.02579,truck), chargingStation(chargingStation12,19.3876,-99.07765,128), storage(storage2,19.32609,-99.09198,12589,0,[]), dump(dump13,19.4271,-99.03601), shop(shop0,19.33569,-99.16989,1,[item(item4,101,13),item(tool0,84,20),item(tool3,126,18),item(tool5,108,16),item(tool6,101,12)]), workshop(workshop9,19.44614,-99.19569), chargingStation(chargingStation4,19.30961,-99.03329,119), storage(storage12,19.39664,-99.03379,9594,0,[]), workshop(workshop10,19.44087,-99.14081), step(0), entity(agentA4,A,19.43752,-99.08263,drone), entity(agentA27,A,19.33246,-99.10792,truck), lastActionParams([]), chargingStation(chargingStation5,19.35958,-99.1865,73), dump(dump7,19.36426,-99.03392), storage(storage0,19.32686,-99.19329,9604,0,[]), entity(agentA24,A,19.37424,-99.05352,truck), entity(agentA17,A,19.37227,-99.13973,car), dump(dump0,19.33927,-99.18741), chargingStation(chargingStation2,19.33813,-99.08956,98), facility(), entity(agentA21,A,19.3971,-99.05624,truck), chargingStation(chargingStation9,19.35086,-99.0163,53), lastAction(noAction), entity(agentA18,A,19.39969,-99.02349,car), shop(shop2,19.32144,-99.0697,3,[item(item0,90,14),item(item6,91,10),item(tool5,133,19)]), workshop(workshop3,19.37344,-99.09335), shop(shop13,19.44068,-99.1147,5,[item(item5,69,6),item(tool0,69,19),item(tool1,85,20)]), storage(storage6,19.3626,-99.11757,13702,0,[]), chargingStation(chargingStation0,19.31722,-99.18127,140), dump(dump10,19.38139,-99.02397), entity(agentA12,A,19.33519,-99.09793,motorcycle), entity(agentA20,A,19.40171,-99.19236,car), storage(storage1,19.30076,-99.12679,7824,0,[]), entity(agentA3,A,19.40928,-99.11384,drone), dump(dump5,19.34982,-99.14985), shop(shop9,19.39585,-99.04156,1,[item(item0,70,18),item(item3,95,9),item(item4,141,20),item(item7,16,6),item(tool4,37,20),item(tool5,121,17),item(tool6,120,8),item(tool7,45,9)]), chargingStation(chargingStation7,19.37113,-99.11836,54), storage(storage5,19.36626,-99.12744,11163,0,[]), chargingStation(chargingStation8,19.3591,-99.05357,111), entity(agentA1,A,19.37562,-99.00317,drone), chargingStation(chargingStation11,19.41131,-99.14265,130), storage(storage8,19.3902,-99.18367,12169,0,[]), lon(-99.17834), shop(shop14,19.42382,-99.03512,3,[item(item1,99,17),item(item3,105,9),item(item4,139,19),item(item7,14,20),item(tool0,72,13),item(tool4,36,15),item(tool6,97,19)]), entity(agentA13,A,19.43401,-99.06124,car), chargingStation(chargingStation10,19.38384,-99.17284,122), dump(dump11,19.42418,-99.17356), workshop(workshop11,19.43077,-99.02892), storage(storage11,19.41385,-99.05545,13467,0,[]), entity(agentA23,A,19.44255,-99.15922,truck), shop(shop12,19.43897,-99.14012,2,[item(item1,82,10),item(tool2,56,15),item(tool3,118,19)]), entity(agentA9,A,19.32065,-99.13607,motorcycle), entity(agentA26,A,19.38986,-99.14356,truck), storage(storage10,19.40745,-99.10503,11491,0,[]), entity(agentA10,A,19.3473,-99.19299,motorcycle), actionID(0), requestAction, storage(storage3,19.30459,-99.01727,14934,0,[]), shop(shop7,19.39279,-99.1337,5,[item(item0,67,17),item(item1,92,13),item(item2,87,5),item(tool0,68,11),item(tool7,47,17)]), entity(agentA14,A,19.44007,-99.14925,car), entity(agentA11,A,19.44882,-99.19551,motorcycle), entity(agentA22,A,19.33237,-99.02805,truck), dump(dump2,19.31402,-99.05739), dump(dump12,19.44191,-99.08681), shop(shop8,19.38367,-99.10324,3,[item(item2,84,7),item(item4,144,16),item(item7,17,8),item(tool1,82,11),item(tool3,141,12),item(tool4,39,20),item(tool5,133,9),item(tool6,132,13),item(tool7,53,19)]), entity(agentA8,A,19.30023,-99.19738,motorcycle), dump(dump6,19.37424,-99.09267), workshop(workshop8,19.41512,-99.01923), charge(250), shop(shop3,19.33139,-99.00328,1,[item(item0,70,20),item(tool0,91,9),item(tool7,42,10)]), dump(dump3,19.31904,-99.01868), workshop(workshop2,19.33312,-99.08554), storage(storage9,19.41272,-99.15535,9557,0,[]), storage(storage4,19.36119,-99.17035,8040,0,[]), workshop(workshop4,19.37509,-99.05729), lat(19.38689), shop(shop6,19.39694,-99.1675,5,[item(item1,79,15),item(item2,62,14),item(item5,78,10),item(item7,16,17),item(tool4,39,18)]), entity(agentA2,A,19.38689,-99.17834,drone), shop(shop5,19.37946,-99.07389,2,[item(item1,103,15),item(item4,99,9),item(item7,17,13),item(tool1,89,11),item(tool4,37,17),item(tool5,103,7),item(tool6,129,11)]), chargingStation(chargingStation13,19.38638,-99.02568,79), entity(agentA16,A,19.31248,-99.0403,car), entity(agentA6,A,19.30774,-99.01944,motorcycle), money(50000), entity(agentA15,A,19.30406,-99.10986,car), chargingStation(chargingStation16,19.4328,-99.03119,89), storage(storage15,19.43708,-99.0397,14486,0,[]), deadline(1514672810536), routeLength(0), entity(agentA28,A,19.30451,-99.04253,truck), dump(dump1,19.3315,-99.10955), workshop(workshop1,19.33872,-99.15421), workshop(workshop0,19.33281,-99.1987), dump(dump4,19.34984,-99.19905), shop(shop11,19.42324,-99.19889,4,[item(item1,98,8),item(item3,101,12),item(item4,104,9),item(item6,97,14),item(tool1,87,15)]), load(0), chargingStation(chargingStation6,19.35604,-99.12279,120), chargingStation(chargingStation14,19.447,-99.1726,51)]
					// playerName: agentA2 (of entity connectoinA2)
					//
					// allPercept will have mappings from entity (of the playerName) to Collection<Percept>
					// 		a percept is just one bit of info as an atom, like map(mexico), route([..]), item(...), or shop(....)
					// Since a player is of one entity type only, we just care about the first (and only) mapping
					// which we store in percepts (via get(0)). So percept is Collection<value>
//					val allPercepts : Map<String, Collection<Percept>> = MT_senseAllPlayerPercepts(playerName) // This is blocking!
//					val entityType = allPercepts.keySet().get(0)	// we only gather the first map as agents are of 1 entity only
					// val percepts = allPercepts.get(entityType)
//					info("Player agent {0} (of entity type {3}) received {1} percepts (type: {2})", playerName,
//						Util.getNoOfPercepts(percepts), Util.getTypePercept(percepts), entityType)

					// Then, allPercept.value() will yield a collection of the values: Collection<Collection<Percept>>
					// var percepts = allPercepts.values().get(0) // this will get the first collection (of percepts)

					// TODO: More compact but complains "percepts cannot be resolved to a type": SARL compilation issue?
					// Collapses all sensors for the agent (who may be associated with many entities) into one list of Percept
					// var percepts : List<Percept> = new ArrayList<Percept>
					// allPercepts.values().forEach[percepts::addAll]	// works even if an agent is mapped to many entities


					// Now the simplest way, just give me the percepts of player (assuming player is of 1 entity)
					// The percepts will also include all the simStart information, even if we are on requestAction message
					// I think the EIS was done to do that, so agents can re-start if necessary and have all sim info in next percept
					val percepts : Collection<Percept> = MT_sensePlayerPercepts(playerName) // This is blocking!
					val myServerName = Util.getAgentName(percepts)
			
					info("EI Player {0} (game entity name {3}) has RECEIVED {1} PERCEPTS (type: {2})", 
						playerName, Util.getNoOfPercepts(percepts), Util.getTypePercept(percepts), myServerName)
                    
					// Populate general data (all entities, team, simstart) static buffers
					if (Util.populateDataBuffers(playerName, percepts)) {}
				 	
					// SELF:
					//	Add the action results of playerName(self) to percept aggregator
					//	Add an the agent state for the playerNamein the aggregator (contains location, items holding, etc)
					aggregator.addActionResults(playerName, percepts)
					
					var PlayerState = PlayerStateBuilder.build(myServerName, percepts) // build a new agent state from percept
					aggregator.addTeamMember(playerName, PlayerState) // Fill the aggregator with this agent state for playerName
					
					// OTHER ENTITIES: 
                    //	Add to aggregator the info of all other entities that are not part of the team (not agents)
                    aggregator.addEntities()

					// FACILITIES: Aggregate all facilities information 
					// (shop, workshops, charging stations, dump, storage, resourceNodes)
					aggregator.addFacilities(percepts)

					// JOBS: Aggregate all jobs (job, auction, mission, or posted)
					aggregator.addJobs(percepts)
					
				} catch (e : PerceiveException) {
					agent_says("There was an exception perceiving for player {0}: {1}", playerName, e.message)
				} catch (e : Exception) {
					error("Something bad has happened during perception for player {0}: {1}", playerName, e.toString)
				}
            ])

			// If you want to debug the charging stations seen across all agents.
			//
			// System.out.println("##########################################################")
			// System.out.println(aggregator.chargingStations)
			// System.out.println(aggregator.chargingStations.size())
			// System.out.println("##########################################################")
            
            
			// Once aggregator has been filled with what was perceived, process it to emit events
			// By doing this, shared same information across players (e.g., charging stations) is handled once
			process_aggregator(aggregator)

			// This will print always but maybe should be done just once at the start!
			if (SimStartBuffer.mapName !== null) {
				agent_says("I am playing in map {0}", SimStartBuffer.mapName)
			} else {
				agent_says("I still don't know which map I am playing....")
			}
		]
	}
	
	
	// Given a perception aggregator, process it by emitting corresponding events
	def process_aggregator(aggregator : PerceptAggregator) {
		//////////////////////////////////////////////////////////////////////////
		// At this point **aggregator **has all the sensing from all the agents
		// Next, Coordinator will emit events per sensing data separately. All agents in the simulation will receive that.
		// Check current issue (Dec 2017) on SARL dropping some of these events:
		// https://github.com/sarl/sarl/issues/713#issuecomment-322680153


		// Emit SARL events for each TEAM percept (now just the money)
		var allEntityPercepts = new HashSet<EntityPercept>()
		allEntityPercepts.addAll(aggregator.getTeamMemberPercepts())
		allEntityPercepts.addAll(aggregator.getGameEntityPercepts())
		agent_says("Emitting {0} event percepts about {1}", allEntityPercepts.length, "ENTITIES")
		for (e : allEntityPercepts) {
			emit(e)
		}

		// Emit SARL events for each ACTION RESULT (of every agent as they all have been aggregated)
		var actionPercepts = aggregator.getActionPercepts();
		agent_says("Emitting {0} event percepts about {1}", actionPercepts.length, "RESULT OF ACTIONS")
		for (e : actionPercepts) {
			emit(e);
		}

		// Emit SARL events for all perception about FACILITIES (shops, charging stations, workshops, dumps, storage, resources)
		var allFacilityPercepts = new ArrayList<FacilitySensedPercept>()
		allFacilityPercepts.addAll(aggregator.shopSensedPercepts)
		allFacilityPercepts.addAll(aggregator.chargingStationSensedPercepts)
		allFacilityPercepts.addAll(aggregator.workshopSensedPercepts)
		allFacilityPercepts.addAll(aggregator.dumpSensedPercepts)
		allFacilityPercepts.addAll(aggregator.storageSensedPercepts)
		allFacilityPercepts.addAll(aggregator.resourceSensedPercepts)
		agent_says("Emitting {0} event percepts about {1}", allFacilityPercepts.length, "FACILITIES")
		for (e : allFacilityPercepts) {
			emit(e)
		}

		// Emit SARL events for all perception about JOBS (regular, auctions, team jobs, missions)
		var allJobPercepts = new ArrayList<JobPercept>()
		allJobPercepts.addAll(aggregator.regularJobPercepts)
		allJobPercepts.addAll(aggregator.teamJobPercepts)
		allJobPercepts.addAll(aggregator.auctionJobPercepts)
		allJobPercepts.addAll(aggregator.missionJobPercepts)
		agent_says("Emitting {0} event percepts about {1}", allJobPercepts.length, "JOBS")
		for (e : allJobPercepts) {
			emit(e)
		}
	}

	/** 
	 * Receives a constrained action from an agent. 
	 * Once the constraints are met the communicator will pass the action to the server. 
	 */
    on E_AgentAction [occurrence.constraints !== null] {
		// TODO: factor in constraints once constraints are met
		performAction(occurrence.playerName, occurrence.action)
	}
	/** 
	 * Used to receive a unconstrained action.
	 * Once an unconstrained action has been received from an agent the communicator will communicate it with the server
	 * 
	 */
	on E_AgentAction [occurrence.constraints === null] {
        performAction(occurrence.playerName, occurrence.action)
	}
	/** 
	 * A basic method for sending actions the the EIS server
	 * If sending fails, the exception is caught and logged. 
	 */
	def performAction(playerName: String, action : Action) {
        debug("Performing action {1} for player {0}", playerName, action.toProlog())
		try {
			// perform the action by playerNamein the EIS
            MT_executeAction(playerName, action);
		} catch (e : ActException) {
            if (action !== null)
				warning("Could not perform action " + action + " for " + playerName);
		}
	}

	on WorkshopSensedPercept {
		agent_says("I have seen a workshop named {0}", occurrence.workshop.name)
	}




}
