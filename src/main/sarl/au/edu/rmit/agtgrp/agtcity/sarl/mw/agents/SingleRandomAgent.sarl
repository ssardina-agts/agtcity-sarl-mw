/** 
 * SARL-MASSIM - Interface between the SARL agent-oriented language 
 * and the MASSIM 2017-2020 server
 * 
 * Copyright (C) 2017-2020 The SARL-MASSIM Authors.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package au.edu.rmit.agtgrp.agtcity.sarl.mw.agents

// MASSIM EIS imports

import au.edu.rmit.agtgrp.agtcity.sarl.mw.aggregator.PerceptAggregator
import au.edu.rmit.agtgrp.agtcity.sarl.mw.capacities.C_MassimTalking
import au.edu.rmit.agtgrp.agtcity.sarl.mw.capacities.C_Reporting
import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.E_SenseEnvironment
import au.edu.rmit.agtgrp.agtcity.sarl.mw.skills.S_ConsoleReporting
import au.edu.rmit.agtgrp.agtcity.sarl.mw.skills.S_MassimTalking
import au.edu.rmit.agtgrp.agtcity.sarl.mw.utils.ConfHandler
import eis.exceptions.ActException
import eis.exceptions.PerceiveException
import eis.iilang.Action
import eis.iilang.EnvironmentState
import eis.iilang.Identifier
import eis.iilang.Percept
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.Schedules
import java.nio.file.Paths
import java.util.Collection
import java.util.Map
import java.util.Random
import java.util.Set

/** 
 * This is a monolithic SARL agent to manage ALL the entity agents in the  game simulation.
 */
@SuppressWarnings("potential_field_synchronization_problem")
agent SingleRandomAgent {
	uses Logging, Lifecycle, DefaultContextInteractions
	uses C_Reporting, C_MassimTalking
	uses Schedules


	val myName = "Single-RANDOM-Agent"
	val agentLogLevel = 3 // debug = 4

	// Data kept by this single SARL agent: just the step number
	var last_step : int
	var facilities : Set<String>
	var rand : Random
	var aggregator : PerceptAggregator // used to collect all the (common) percepts from all agents (provided by MW)

	// These are the entities will control
//	val myEntityConnections = #["connectionA1", "connectionA2", "connectionA3", "connectionA4", "connectionA5",
	// "connectionA6"]
//	val myEntityConnections = #["connectionA1", "connectionA5"] // simpler testing, just 2 players
	val myEntityConnections = #["connectionA1"] // simpler testing, just 2 players


	
	
	
	/* 
	 * SARL agent is initialized 
	 *
	 * The agent may control one more more game entities.
	 * 
	 * To do so, the agent will install a S_MassimTalking skill, which allows the agent to talk to the game server.
	 * 
	 * The skill requires an EI configuration file "eismassimconfig.json" containing all the server info and
	 * all entity connections available (including username/password to authenticate) which should include at least the
	 * connections in myEntityConnections will be the ones this SARL agent will control
	 * 
	 * 
	 * Different EI config files can be kept in different folders under conf/
	 * 
	 * If a directory is given in CLI argument, then  EI config file eismassimconfig.json is search there.
	 * Otherwise, possible options as per folders under conf/ are scanned and given to user for selection	 * 
	 */
	on Initialize { // Should only be initializing with the EIS as a parameter.
			var args = newArrayList(occurrence.parameters) // may receive config directory at creation
			var eiConfigDir : String
			val eiConfigFileName = "eismassimconfig.json"

			rand = new Random()

			// Create an information aggregator (where all percept info from percepts will be integrated and stored)
			aggregator = new PerceptAggregator() 
			
			// Give reporting skill via console
			setSkill(new S_ConsoleReporting(myName), C_Reporting)
			setLogLevel(4)

			/*
			 * FIRST, collect the directory where the server and player configuration files to be used are
			 */
			agent_says("PHASE 1: INSTALL MASSIM-TALKING SKILL WITH CONFIG FILE: {0}", eiConfigFileName)
			if (args.length != 0) {
				eiConfigDir = args.get(0) as String	// use the config dir given as CLI argument
			} else {
				// Ask the user which folder in conf/ is to be used to use the EI config file
				eiConfigDir = ConfHandler.getConfDir()
			}
			val eiConfigurationFile = Paths.get(eiConfigDir, eiConfigFileName)

			debug("
				***************************************************
				Configuration settings: 
				\t My SARL agent name: {0}
				\t EI configuration file: {1}
				***************************************************", myName, eiConfigurationFile)
			
			try {
				/*
				 * SECOND, install skill to talk to the server using EI config file (no actual connection to entities yet)
				 * 
				 */
				agent_says("PHASE 2: INSTALL MASSIM-TALKING SKILL WITH EI CONFIG FILE {0}", eiConfigurationFile)
				setSkill(new S_MassimTalking(eiConfigurationFile), C_MassimTalking)


				/* 
				 * Next, we initialize the Environment Interface (EIS)
				 * This involves connecting to game server, authenticating entities, and registering players in EI
				 */
				agent_says("PHASE 3: INITIALIZING CONNECTIONS {1} USING EI CONFIG FILE {0}", eiConfigFileName,
					myEntityConnections.toString)
				if (myEntityConnections !== null)
					myEntityConnections.forEach [ entityName : String |
						MT_registerEntityByName(entityName) // register entities to control (no authentication yet)
					]
				if (MT_initialize()) {
					agent_says("The EI is now initialized, entities are being authenticated...")
				} else {
					agent_shouts("Something wrong when initializing the EI, I am finished...")
					killMe
				}
	
				agent_says("PHASE 4 (FINAL): EMIT E_sendEnviroment() to start sensing and acting")
				in(2000)[emit(new E_SenseEnvironment())]	// wait 2 seconds to allow everyone to auhenticate to server
			} catch (e : Exception) {
				error("Sorry but I was not able to initialize the skill to talk to server! Message: {0}", e.message)
				e.printStackTrace()
				killMe
			}
			
	}

	/* 
	 * Handle the process of sensing the environment
	 */
	on E_SenseEnvironment {
		agent_shouts("Start sensing the environment")
		var step = 0

		// While the environment is running, wait for new percepts (read percepts for each player registered/connected)
		while (MT_getStatus() == EnvironmentState.RUNNING) {
			MT_getPlayersNames().forEach([ playerName : String |

				// all percepts for the player: (role/entity of agent --> collection of single percepts)
				// In this game, players usually are of one role/entity, so we will store that single set of percepts
				// in variable percepts (the first value of allPercepts)
				var allPercepts : Map<String, Collection<Percept>>
				var percepts : Collection<Percept>
				try {
					debug("About to sense percepts for player {0}", playerName)
					percepts = MT_sensePlayerPercepts(playerName) // This is blocking!
					debug("Finished sensing percepts for player {0}", playerName)

					// Updating the PlayerState of the player where percepts come from
					// The skill S_MassimTalking already maintains a PlayerState object per player (MT_getPlayerState(playerName))
					debug("About to update entity state for for player {0}", playerName)
					MT_updatePlayerState(playerName, percepts) // update the agent data
					debug("Finish updating entity state for for player {0}", playerName)

					
					aggregator.fillFacilitiesAndJobs(percepts)		
					agent_shouts("Facilities and Jobs aggregated for entity {0}", playerName)
					
					facilities = aggregator.getFacilitiesNames()
					agent_shouts("Set of facilities known: {0}", facilities)
			

					// update the last step if the percept just processed has a higher step number
					last_step = MT_getStepNo()


					agent_shouts("I am finished sensing the environment - Step {0} for player {1}", MT_getStepNo(),
						playerName)
				} catch (e : PerceiveException) {
					agent_shouts("There was an error in perception ({0}), maybe not yet connected? Will try later...", e.message)
				} catch (e : Exception) {
					error("Something bad has happened during perception for player **{0}**: {1}", playerName,
						e.toString)
					throw e
				}
			])

			agent_shouts(
				"Finished sensing the environment for all the player connections. Next report and act for step {0}!!!",
				last_step)

			// 1 - Report some information per player agent
			MT_getPlayersNames().forEach([ playerName : String |
				agent_says(MT_reportPlayerState(playerName)) // report agent state
			])

			// 2 - Each control player agent should travel to some random facility (if in route, continue)
			MT_getPlayersNames.forEach([ playerName : String |
				if (MT_getPlayerState(playerName).routeLength > 0) {
					agent_says("Seems player **{0}** is already traveling: {1} steps to go!", playerName,
						MT_getPlayerState(playerName).routeLength)
					performAction(playerName, new Action("continue"))
				} else if (facilities !== null && facilities.length > 0) {
					// Pick some random facility and go!
					val destination = facilities.get(rand.nextInt(facilities.length - 1))
					performAction(playerName, new Action("goto", new Identifier(destination)))
					agent_says("I will send player **{1}** to location {0}", destination, playerName)
				} else {
					agent_shouts("I just don't know any facility to go yet, sorry...!")
				}
			])
		}

		agent_shouts("Environment Interface not running anymore, done sensing....")
	}


	/** 
	 * A basic method for sending actions the the EIS server
	 * If sending fails, the exception is caught and logged. 
	 */
	def performAction(playerName : String, action : Action) {
		agent_says("Performing action **{1}** for player **{0}**", playerName, action.toProlog())
		try {
			// perform the action by agentName in the EIS
			MT_executeAction(playerName, action)
		} catch (e : ActException) {
			if (action !== null)
				warning("Could not perform action {0} for player **{1}**", action, playerName)
		}
	}

}
// /////////////////////////////////////////////////
// END OF FILE
// ///////////////////////////////////////////////// 