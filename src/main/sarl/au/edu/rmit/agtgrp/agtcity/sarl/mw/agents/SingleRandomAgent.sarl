/** 
 * SARL-MASSIM - Interface between the SARL agent-oriented language 
 * and the MASSIM 2017 server
 * Copyright (C) 2017 The SARL-MASSIM Authors.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package au.edu.rmit.agtgrp.agtcity.sarl.mw.agents

// MASSIM EIS imports
import eis.iilang.Action // needed to do actions
import eis.iilang.Percept // needed to process percepts
import eis.iilang.EnvironmentState;

// SARL imports
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging

// General Java tools
import java.nio.file.Paths

import eis.exceptions.PerceiveException
import eis.exceptions.ActException
import eis.iilang.Identifier

// Import project content
import au.edu.rmit.agtgrp.agtcity.sarl.mw.utils.ConfHandler

import au.edu.rmit.agtgrp.agtcity.sarl.mw.capacities.C_Reporting
import au.edu.rmit.agtgrp.agtcity.sarl.mw.capacities.C_MassimTalking
import au.edu.rmit.agtgrp.agtcity.sarl.mw.skills.S_ConsoleReporting
import au.edu.rmit.agtgrp.agtcity.sarl.mw.skills.S_MassimTalking17
import au.edu.rmit.agtgrp.agtcity.sarl.mw.aggregator.Util
import au.edu.rmit.agtgrp.agtcity.sarl.mw.aggregator.PerceptAggregator

import io.sarl.core.Schedules
import java.util.Collection
import java.util.Map
import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.E_SenseEnvironment
import java.util.Random
import java.util.Set

/** 
 * @author Sebastian Sardina (ssardina@gmail.com
 * 
 * This is a monolithic SARL agent that uses the S_MassimTalking17 skill 
 * to manage ALL the players in the  game simulation.
 */
@SuppressWarnings("potential_field_synchronization_problem")
agent SingleRandomAgent {
	uses Logging, Lifecycle, DefaultContextInteractions
	uses C_Reporting, C_MassimTalking
	uses Schedules


	val myName = "Single-RANDOM-Agent"
	val agentLogLevel = 3 // debug = 4

	// Data kept by this single SARL agent: just the step number
	var last_step : int
	var facilities : Set<String>
	var rand : Random
	var aggregator : PerceptAggregator // used to collect all the (common) percepts from all agents (provided by MW)

	// These are the connection players we will control
	var myConnections  = #["connectionA1", "connectionA2", "connectionA3", "connectionA4", "connectionA5", "connectionA6"]

	/* 
	 * Agent may receive the path directory where the config files for server connection
	 * and player authentications are located. Otherwise, will query via terminal.
	 */
	on Initialize { // Should only be initializing with the EIS as a parameter.
			var args = newArrayList(occurrence.parameters) // may receive directory conf directory
			var eiConfigDir : String
			val eiMassimConfigFile = "eismassimconfig.json"

			rand = new Random()

			aggregator = new PerceptAggregator() // collect all the percepts from all agents
			// Give reporting skill via console
			setSkill(new S_ConsoleReporting(myName), C_Reporting)
			setLogLevel(4)

			/*
			 * First, we collect the directory where the server and player configuration files to be used are
			 */
			agent_says("PHASE 1: INITIALIZING MASSIM-TALKING SKILL WITH SERVER CONFIG FILE: {0}", eiMassimConfigFile)
			if (args.length != 0)
				eiConfigDir = args.get(0) as String
			else {
				// Ask the user which subdirectory in conf/ we need to use to find the server config JSON file
				eiConfigDir = ConfHandler.getConfDir()
			}
			debug("Configuration settings: 
				\t My SARL agent name: {0}
				\t Directory of configuration files: {1}
				\t File containing authentication and sever info: {2}", myName, eiConfigDir, eiMassimConfigFile)

			/*
			 * We give the agent the skill to talk to the MASSIM game server. 
			 * We provide server JSON config file and player JSON config file
			 */
			// Give agent ability to talk to MASSIM server
			setSkill(new S_MassimTalking17(Paths.get(eiConfigDir, eiMassimConfigFile)), C_MassimTalking)

			/*
			 * Next, we initialize the Environment Interface (EIS)
			 * This involves connecting to game server, authenticating entities, and registering players in EI
			 */
			agent_says("PHASE 2: INITIALIZING EI WITH FILE {0} TO CONTROL CONNECTIONS: {1} ", eiMassimConfigFile,
				myConnections.toString)
			if (myConnections !== null) myConnections.forEach [ player : String |
				MT_registerEntityByName(player) // entities to control
			] 
			if (MT_initialize()) {
				agent_says("The EI is now initialized, entities are being authenticated...")
			} else {
				agent_shouts("Something wrong when initializing the EI, I am finished...")
				killMe
			}

			agent_shouts("I am now alive! Will start working now (sending and acting!)...")

			// We are ready, now start the cycle for sensing the environment (and thus acting)!
			// Wait 2 seconds to allow everyone to authenticate to server
			in(2000)[emit(new E_SenseEnvironment())]
	}

	/* 
	 * Handle the process of sensing the environment
	 */
	on E_SenseEnvironment {
		agent_shouts("Start sensing the environment")
		var step = 0

		// Initializes three static data buffers for entities, teams and sim-start
		// Util is provided by the MW as part of the aggregator package
		if (Util.initDataBuffers()) {}

		// While the environment is running, wait for new percepts (read percepts for each player registered/connnected)
		while (MT_getStatus() == EnvironmentState.RUNNING) {
			MT_getPlayersNames().forEach([ playerName : String |

				// all percepts for the player: (role/entity of agent --> collection of single percepts)
				// In this game, players usually are of one role/entity, so we will store that single set of percepts
				// in variable percepts (the first value of allPercepts)
				var allPercepts : Map<String, Collection<Percept>>
				var percepts : Collection<Percept>
				try {
					percepts = MT_sensePlayerPercepts(playerName) // This is blocking!

					// Process the percepts by updating the PlayerState of the player in question
					// The skill S_MassimTalking17 maintains a PlayerState object per player
					// ATTENTION: THis is already done by the MT once data is sensed!!!
//					MT_getPlayerState(playerName).update(percepts) // update the agent data
					info(MT_getPlayerState(playerName).reportState)
					
					// FACILITIES: Aggregate all facilities information that are the same info for everyone
					// (shop, workshops, charging stations, dump, storage, resourceNodes)
					if (Util.populateDataBuffers(percepts)) {}
					
					aggregator.addFacilities(percepts)
					facilities = aggregator.getFacilitiesNames()

					// JOBS: Aggregate all jobs (job, auction, mission, or posted)
					aggregator.addJobs(percepts)

					// update the last step if the percept just processed has a higher step number
					if(last_step < MT_getPlayerState(playerName).step) last_step = MT_getPlayerState(playerName).step


					agent_shouts("I am finished sensing the environment - Step {0} for player {1}",
						MT_getPlayerState(playerName).step, playerName)
				} catch (e : PerceiveException) {
					agent_shouts("There was an error in perception ({0}), maybe not yet connected? Will try later...", e.message)
				} catch (e : Exception) {
					error("Something bad has happened during perception for player **{0}**: {1}", playerName, e.toString)
				}
			])

			agent_shouts(
				"Finished sensing the environment for all the players. I will instruct action for step {0}!",
				last_step)

			// 1 - Report some information per agent
			MT_getPlayersNames().forEach([ playerName : String |
				agent_says(MT_getPlayerState(playerName).reportState()) // report agent state
			])

			// 2 - Travel to some random facility
			MT_getPlayersNames.forEach([ playerName : String |
				if (MT_getPlayerState(playerName).routeLength > 0) {
					agent_says("Seems player **{0}** is already travelling: {1} steps to go!", playerName,
						MT_getPlayerState(playerName).routeLength)
					performAction(playerName, new Action("continue"))
				} else if (facilities !== null && facilities.length > 0) {
					// Pick some random facility and go!
					val destination = facilities.get(rand.nextInt(facilities.length - 1))
					performAction(playerName, new Action("goto", new Identifier(destination)))
					agent_says("I will send player **{1}** to location {0}", destination, playerName)
				} else {
					agent_shouts("I just don't know any facility to go yet, sorry...!")
				}
			])
		}

		agent_shouts("Environment Interface not running anymore, done sensing....")
	}


	/** 
	 * A basic method for sending actions the the EIS server
	 * If sending fails, the exception is caught and logged. 
	 */
	def performAction(playerName : String, action : Action) {
		agent_says("Performing action **{1}** for player **{0}**", playerName, action.toProlog())
		try {
			// perform the action by agentName in the EIS
			MT_executeAction(playerName, action)
		} catch (e : ActException) {
			if (action !== null)
				warning("Could not perform action {0} for player **{1}**", action, playerName)
		}
	}

}
// /////////////////////////////////////////////////
// END OF FILE
// ///////////////////////////////////////////////// 