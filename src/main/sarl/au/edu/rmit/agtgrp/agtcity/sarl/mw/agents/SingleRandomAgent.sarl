/** 
 * SARL-MASSIM - Interface between the SARL agent-oriented language 
 * and the MASSIM 2017-2020 server
 * 
 * Copyright (C) 2017-2020 The SARL-MASSIM Authors.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package au.edu.rmit.agtgrp.agtcity.sarl.mw.agents

// MASSIM EIS imports

import au.edu.rmit.agtgrp.agtcity.sarl.mw.aggregator.PerceptAggregator
import au.edu.rmit.agtgrp.agtcity.sarl.mw.capacities.C_MassimTalking
import au.edu.rmit.agtgrp.agtcity.sarl.mw.capacities.C_Reporting
import au.edu.rmit.agtgrp.agtcity.sarl.mw.skills.S_ConsoleReporting
import au.edu.rmit.agtgrp.agtcity.sarl.mw.skills.S_MassimTalking
import au.edu.rmit.agtgrp.agtcity.sarl.mw.utils.ConfHandler
import eis.exceptions.PerceiveException
import eis.iilang.Action
import eis.iilang.EnvironmentState
import eis.iilang.Identifier
import eis.iilang.Percept
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.Schedules
import java.nio.file.Paths
import java.util.Collection
import java.util.Random
import java.util.Set

event E_SenseEnvironment

event E_EntitySensed {
	var stepNo : int
	var entityName : String
	var percepts : Collection<Percept>
	
	new(stepNo : int, entityName : String, percepts : Collection<Percept>) {
		this.stepNo = stepNo
		this.entityName = entityName
		this.percepts = percepts
	}
	
}

/** 
 * This is a monolithic SARL agent to manage ALL the entity agents in the  game simulation.
 */
@SuppressWarnings("potential_field_synchronization_problem")
agent SingleRandomAgent {
	uses Logging, Lifecycle, DefaultContextInteractions
	uses C_Reporting, C_MassimTalking
	uses Schedules


	val myName = "Single-RANDOM-Agent"
	val agentLogLevel = 4 // debug = 4 this is for the high-level agent, not for SARL

	// Server information: registration configuration file and entities that this agent will control
	val eiRegistrationFileName = "eismassimconfig.json" // the name of the registration file
	//	val myEntityConnections = #["entityA1", "entityA2", "entityA3", "entityA4", "entityA5"]
	val myConnectedEntities = #["entityA1", "entityA5"] // simpler testing, just 2 players


	// Data kept by this single SARL agent: just the step number
	var last_step : int = -1
	var facilities : Set<String>
	var rand : Random
	var aggregator : PerceptAggregator // used to collect all the (common) percepts from all agents (provided by MW)
	
	
	/* 
	 * SARL agent is initialized 
	 *
	 * The SARL agent may control one more more game entities (trucks, motorcycles, drones, etc).
	 * 
	 * To do so, the agent will install a S_MassimTalking skill, which allows the agent to talk to the game server.
	 * 
	 * The skill uses the Environment Interface (EI) for MASSIM which provides a high-level connection to the game server.
	 * The skill needs an EI registration file "eismassimconfig.json" containing all the server info and
	 * all entity connections available (including username/password to authenticate) 
	 * We can tell the skill to control an sense among those available connections
	 * 
	 * Different EI registration files can be kept in different folders under conf/
	 * 
	 * If a directory is given in CLI argument, then  EI registration file eismassimconfig.json is search there.
	 * Otherwise, possible options as per folders under conf/ are scanned and given to user for selection	 * 
	 */
	on Initialize { // Should only be initializing with the EIS as a parameter.
			var args = newArrayList(occurrence.parameters) // may receive config directory at creation
			var eiConfigDir : String

			rand = new Random()

			// Create an information aggregator (all percept info will be integrated here by the MW)
			aggregator = new PerceptAggregator() 
			
			// Give reporting skill via console
			setSkill(new S_ConsoleReporting(myName), C_Reporting)
			setLogLevel(4)	// set debug level

			/*
			 * FIRST, collect the directory where the server and player configuration files to be used are
			 */
			agent_says("PHASE 1: INSTALL MASSIM-TALKING SKILL WITH CONFIG FILE: {0}", eiRegistrationFileName)
			if (args.length != 0) {
				eiConfigDir = args.get(0) as String	// use the config dir given as CLI argument
			} else {
				// Ask the user which folder in conf/ is to be used to use the EI config file
				eiConfigDir = ConfHandler.getConfDir()
			}
			val eiRegistrationFile = Paths.get(eiConfigDir, eiRegistrationFileName)

			debug("
				***************************************************
				Configuration settings: 
				\t My SARL agent name: {0}
				\t EI registration file: {1}
				***************************************************", myName, eiRegistrationFile)
			
			try {
				/*
				 * SECOND, install skill to talk to the server using EI registration file 
				 * (no actual connection to entities yet, just recording of registration file to be used)
				 * 
				 */
				agent_says("PHASE 2: INSTALL MASSIM-TALKING SKILL WITH EI REGISTRATION FILE {0}", eiRegistrationFile)
				setSkill(new S_MassimTalking(eiRegistrationFile, false), C_MassimTalking)


				/* 
				 * THIRD, we configure the skill by providing which specific entities this agent will control
				 * 	The agents to control have to be among those listed in the registration file
				 * 	No actual connection (or server authentication) happens at this step
				 */
				agent_says("PHASE 3: REGISTERING ENTITIES TO CONTROL: ", myConnectedEntities.toString)
				if (myConnectedEntities !== null)
					myConnectedEntities.forEach [ entityName : String |	// entityA1, entityA2, .../entityAn
						MT_registerEntityByName(entityName) // register entities to control (no authentication yet)
						agent_says("I have registered entity **{0}** for control and perception.", entityName)
					]

				/* 
				 * FOURTH, we establish the connection to the game server via the EI 
				 * * 
				 * All entities registered for control are authenticated and connected to the server
				 * 
				 */
				agent_says("PHASE 4: INITIALIZING CONNECTIONS {1} USING EI CONFIG FILE {0}", eiRegistrationFileName);
				if (MT_initialize()) {
					agent_says("The EI is now initialized, entities are being authenticated...")
				} else {
					agent_shouts("Something wrong when initializing the EI, I am finished...")
					killMe
				}

			/* 
			 * FIFTH, finally all entities registered and connected for control and sensing.
			 * 	So, send an event to start sending and controlling 
			 * 
			 */
				agent_says("PHASE 4 (FINAL): Emit E_SenseEnvironment() to start sensing and acting")
				in(2000)[emit(new E_SenseEnvironment())]	// wait 2 seconds to allow everyone to auhenticate to server
			} catch (e : Exception) {
				error("Sorry but I was not able to initialize the skill to talk to server! Message: {0}", e.message)
				e.printStackTrace()
				killMe
			}
	}

	/* 
	 * Handle the process of sensing the environment
	 */
	on E_SenseEnvironment {
		agent_shouts("Start sensing the environment for the following entities I control: {0}", MT_getEntityNames)

		// While the environment is running, wait for new percepts (read percepts for each player registered/connected)
		while (MT_getStatus() == EnvironmentState.RUNNING && !MT_getEntityNames().empty) {
			MT_getEntityNames().forEach([ entityName : String |

				// All percepts for the player: (role/entity of agent --> collection of single percepts)
				// In this game, players usually are of one role/entity, so we will store that single set of percepts
				// in variable percepts (the first value of allPercepts)
				try {
					debug("About to sense percepts for step {0} in player {0}", last_step+1, entityName)
					var percepts : Collection<Percept> percepts = MT_senseEntityPercepts(entityName) // This is BLOCKING!!
					
					// TODO: Change this to debug log
					//var plist = percepts.stream().map([p | return p.name]).collect(Collectors.toList)
					//System.out.println(String.join(",", plist))

					agent_says("I have just sensed player {0} at step {1}", entityName, MT_getStepNo())

					// First step has Sim-Start percepts
					// https://github.com/ssardina-agts/agtcity-server/blob/master/docs/eismassim.md#sim-start-percepts
					if(MT_getStepNo() == 0) aggregator.recordSimStartData(percepts)


					// Updating the PlayerState of the player where percepts come from
					// ATTENTION: This step is already done by the MT once data is sensed, so it is technically not necessary
					// The skill S_MassimTalking already maintains and updates upon sensing a PlayerState object per connected player 
					// That state can be accessed via MT_getPlayerState(playerName)
					// MT_updatePlayerState(playerName, percepts) // update the agent data
					
					aggregator.updateAggregatedGameState(percepts, MT_getStepNo())
					agent_shouts("Facilities and Jobs aggregated for entity {0}", entityName)
					
					facilities = aggregator.getFacilitiesNames()
					agent_shouts("Set of facilities known: {0}", facilities)
			

					// update the last step if the percept just processed has a higher step number
					last_step = MT_getStepNo()
					agent_shouts("I am finished sensing the environment - Step {0} for player {1}", MT_getStepNo(),
						entityName)
					emit(new E_EntitySensed(last_step, entityName, percepts))

				} catch (e : PerceiveException) {
					agent_shouts("There was an error in perception ({0}), maybe not yet connected? Will try later...", e.message)
				} catch (e : Exception) {
					error("Something bad has happened during perception for player **{0}**: {1}", entityName,
						e.toString)
					throw e
				}
			]) // FINISH sensing cycle for all entities - We have sensed every entity now
			agent_shouts("Finished sensing the environment for all the player connections. Next report and act for step {0}!!!",
				last_step)
		} // end of game & sensing finished
	} // end of on E_SenseEnvironment


	/* 
	 * Handled the case when an entity has completed a perception
	 */
	on E_EntitySensed {
		val entity = occurrence.entityName
		agent_shouts("Entity {1} will report and act for step {0}!!!", last_step, entity)
		
		reportState(entity)

		// 2 - Each control player agent should travel to some random facility (if in route, continue)
		if (MT_getEntityState(entity).routeLength > 0) {
			agent_says("Seems player **{0}** is already traveling: {1} steps to go!", entity,
				MT_getEntityState(entity).routeLength)
			if (!MT_executeAction(entity, new Action("continue")))
				agent_shouts("Was not able to successfully send action goto({0}) for entity {1}", "continue", entity)
		} else if (facilities !== null && facilities.length > 0) {
			// Pick some random facility and go!
			val destination = facilities.get(rand.nextInt(facilities.length - 1))
			if (!MT_executeAction(entity, new Action("goto", new Identifier(destination))))
				agent_shouts("Was not able to successfully send action goto({0}) for entity {1}", destination, entity)
			agent_says("I will send player **{1}** to location {0}", destination, entity)
		} else {
			agent_shouts("I just don't know any facility to go yet, sorry...!")
		}
	}
	
	
	def reportState(entity : String) {
		val reportText = String.format("
		========================== REPORT FOR ENTITY %s ==========================
		REPORT OF ENTITY: %s	
		Playing in map **%s** for **%d** simulation steps  
		Team money: %d (seed capital was: %d) 
		Team name: %s			
		========================== REPORT FOR ENTITY %s ========================== 
		",
		entity,
		MT_reportEntityState(entity),
		aggregator.mapName,
		aggregator.simulationLength,
		aggregator.money,
		aggregator.seedCapital, 
		aggregator.team,
		entity
		)
		
		agent_says(reportText) 
		
		
		
	}
	
}
		
// /////////////////////////////////////////////////
// END OF FILE
// ///////////////////////////////////////////////// 