/** 
 * SARL-MASSIM - Interface between the SARL agent-oriented language 
 * and the MASSIM 2017-2020 server
 * 
 * Copyright (C) 2017-2020 The SARL-MASSIM Authors.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package au.edu.rmit.agtgrp.agtcity.sarl.mw.agents

// MASSIM EIS imports

import au.edu.rmit.agtgrp.agtcity.sarl.mw.aggregator.PerceptAggregator
import au.edu.rmit.agtgrp.agtcity.sarl.mw.capacities.C_MassimTalking
import au.edu.rmit.agtgrp.agtcity.sarl.mw.capacities.C_Reporting
import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.E_SenseEnvironment
import au.edu.rmit.agtgrp.agtcity.sarl.mw.skills.S_ConsoleReporting
import au.edu.rmit.agtgrp.agtcity.sarl.mw.skills.S_MassimTalking
import au.edu.rmit.agtgrp.agtcity.sarl.mw.utils.ConfHandler
import eis.exceptions.ActException
import eis.exceptions.PerceiveException
import eis.iilang.Action
import eis.iilang.EnvironmentState
import eis.iilang.Identifier
import eis.iilang.Percept
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.Schedules
import java.nio.file.Paths
import java.util.Collection
import java.util.Map
import java.util.Random
import java.util.Set

/** 
 * This is a monolithic SARL agent to manage ALL the entity agents in the  game simulation.
 */
@SuppressWarnings("potential_field_synchronization_problem")
agent SingleRandomAgent {
	uses Logging, Lifecycle, DefaultContextInteractions
	uses C_Reporting, C_MassimTalking
	uses Schedules


	val myName = "Single-RANDOM-Agent"
	val agentLogLevel = 4 // debug = 4 this is for the high-level agent, not for SARL

	// Server information: registration configuration file and entities that this agent will control
	val eiRegistrationFileName = "eismassimconfig.json" // the name of the registration file
	//	val myEntityConnections = #["entityA1", "entityA2", "entityA3", "entityA4", "entityA5"]
	val myConnectedEntities = #["entityA1", "entityA5"] // simpler testing, just 2 players


	// Data kept by this single SARL agent: just the step number
	var last_step : int
	var facilities : Set<String>
	var rand : Random
	var aggregator : PerceptAggregator // used to collect all the (common) percepts from all agents (provided by MW)
	
	
	/* 
	 * SARL agent is initialized 
	 *
	 * The SARL agent may control one more more game entities (trucks, motorcycles, drones, etc).
	 * 
	 * To do so, the agent will install a S_MassimTalking skill, which allows the agent to talk to the game server.
	 * 
	 * The skill uses the Environment Interface (EI) for MASSIM which provides a high-level connection to the game server.
	 * The skill needs an EI registration file "eismassimconfig.json" containing all the server info and
	 * all entity connections available (including username/password to authenticate) 
	 * We can tell the skill to control an sense among those available connections
	 * 
	 * Different EI config files can be kept in different folders under conf/
	 * 
	 * If a directory is given in CLI argument, then  EI config file eismassimconfig.json is search there.
	 * Otherwise, possible options as per folders under conf/ are scanned and given to user for selection	 * 
	 */
	on Initialize { // Should only be initializing with the EIS as a parameter.
			var args = newArrayList(occurrence.parameters) // may receive config directory at creation
			var eiConfigDir : String

			rand = new Random()

			// Create an information aggregator (all percept info will be integrated here by the MW)
			aggregator = new PerceptAggregator() 
			
			// Give reporting skill via console
			setSkill(new S_ConsoleReporting(myName), C_Reporting)
			setLogLevel(4)	// set debug level

			/*
			 * FIRST, collect the directory where the server and player configuration files to be used are
			 */
			agent_says("PHASE 1: INSTALL MASSIM-TALKING SKILL WITH CONFIG FILE: {0}", eiRegistrationFileName)
			if (args.length != 0) {
				eiConfigDir = args.get(0) as String	// use the config dir given as CLI argument
			} else {
				// Ask the user which folder in conf/ is to be used to use the EI config file
				eiConfigDir = ConfHandler.getConfDir()
			}
			val eiRegistrationFile = Paths.get(eiConfigDir, eiRegistrationFileName)

			debug("
				***************************************************
				Configuration settings: 
				\t My SARL agent name: {0}
				\t EI registration file: {1}
				***************************************************", myName, eiRegistrationFile)
			
			try {
				/*
				 * SECOND, install skill to talk to the server using EI registration file 
				 * (no actual connection to entities yet, just recording of registration file to be used)
				 * 
				 */
				agent_says("PHASE 2: INSTALL MASSIM-TALKING SKILL WITH EI REGISTRATION FILE {0}", eiRegistrationFile)
				setSkill(new S_MassimTalking(eiRegistrationFile), C_MassimTalking)


				/* 
				 * THIRD, we configure the skill by providing which specific entities this agent will control
				 * 	The agents to control have to be among those listed in the registration file
				 * 	No actual connection (or server authentication) happens at this step
				 */
				agent_says("PHASE 3: REGISTERING ENTITIES TO CONTROL: ", myConnectedEntities.toString)
				if (myConnectedEntities !== null)
					myConnectedEntities.forEach [ entityName : String |	// entityA1, entityA2, .../entityAn
						MT_registerEntityByName(entityName) // register entities to control (no authentication yet)
						agent_says("I have registered entity **{0}** for control and perception.", entityName)
					]

				/* 
				 * FOURTH, we establish the connection to the game server via the EI 
				 * * 
				 * All entities registered for control are authenticated and connected to the server
				 * 
				 */
				agent_says("PHASE 4: INITIALIZING CONNECTIONS {1} USING EI CONFIG FILE {0}", eiRegistrationFileName);
				if (MT_initialize()) {
					agent_says("The EI is now initialized, entities are being authenticated...")
				} else {
					agent_shouts("Something wrong when initializing the EI, I am finished...")
					killMe
				}

			/* 
			 * FIFTH, finally all entities registered and connected for control and sensing.
			 * 	So, send an event to start sending and controlling 
			 * 
			 */
				agent_says("PHASE 4 (FINAL): Emit E_SenseEnvironment() to start sensing and acting")
				in(2000)[emit(new E_SenseEnvironment())]	// wait 2 seconds to allow everyone to auhenticate to server
			} catch (e : Exception) {
				error("Sorry but I was not able to initialize the skill to talk to server! Message: {0}", e.message)
				e.printStackTrace()
				killMe
			}
	}

	/* 
	 * Handle the process of sensing the environment
	 */
	on E_SenseEnvironment {
		agent_shouts("Start sensing the environment for the following entities I control: {0}", MT_getEntityNames)
		var step = 0

		// While the environment is running, wait for new percepts (read percepts for each player registered/connected)
		while (MT_getStatus() == EnvironmentState.RUNNING && !MT_getEntityNames().empty) {
			MT_getEntityNames().forEach([ playerName : String |

				// All percepts for the player: (role/entity of agent --> collection of single percepts)
				// In this game, players usually are of one role/entity, so we will store that single set of percepts
				// in variable percepts (the first value of allPercepts)
				var allPercepts : Map<String, Collection<Percept>>
				var percepts : Collection<Percept>
				try {
					debug("About to sense percepts for player {0}", playerName)
					percepts = MT_senseEntityPercepts(playerName) // This is blocking!
					agent_says("I have just sensed player {0} at step {1}", playerName, MT_getStepNo())

					// Updating the PlayerState of the player where percepts come from
					// ATTENTION: This step is already done by the MT once data is sensed, so it is technically not necessary
					// The skill S_MassimTalking already maintains and updates upon sensing a PlayerState object per connected player 
					// That state can be accessed via MT_getPlayerState(playerName)
					// MT_updatePlayerState(playerName, percepts) // update the agent data

					
					aggregator.fillFacilitiesAndJobs(percepts)		
					agent_shouts("Facilities and Jobs aggregated for entity {0}", playerName)
					
					facilities = aggregator.getFacilitiesNames()
					agent_shouts("Set of facilities known: {0}", facilities)
			

					// update the last step if the percept just processed has a higher step number
					last_step = MT_getStepNo()


					agent_shouts("I am finished sensing the environment - Step {0} for player {1}", MT_getStepNo(),
						playerName)
				} catch (e : PerceiveException) {
					agent_shouts("There was an error in perception ({0}), maybe not yet connected? Will try later...", e.message)
				} catch (e : Exception) {
					error("Something bad has happened during perception for player **{0}**: {1}", playerName,
						e.toString)
					throw e
				}
			])	// FINISH sensing cycle for all entities - We have sensed every entity now
	
			agent_shouts(
				"Finished sensing the environment for all the player connections. Next report and act for step {0}!!!",
				last_step)

			// 1 - Report some information per player agent
			MT_getEntityNames().forEach([ playerName : String |
				agent_says(MT_reportEntityState(playerName)) // report agent state
			])

			// 2 - Each control player agent should travel to some random facility (if in route, continue)
			MT_getEntityNames.forEach([ playerName : String |
				if (MT_getEntityState(playerName).routeLength > 0) {
					agent_says("Seems player **{0}** is already traveling: {1} steps to go!", playerName,
						MT_getEntityState(playerName).routeLength)
					performAction(playerName, new Action("continue"))
				} else if (facilities !== null && facilities.length > 0) {
					// Pick some random facility and go!
					val destination = facilities.get(rand.nextInt(facilities.length - 1))
					performAction(playerName, new Action("goto", new Identifier(destination)))
					agent_says("I will send player **{1}** to location {0}", destination, playerName)
				} else {
					agent_shouts("I just don't know any facility to go yet, sorry...!")
				}
			])
		}

		agent_shouts("EI not running anymore or no agents to control, done...")
	}


	/** 
	 * A basic method for sending actions the the EIS server
	 * If sending fails, the exception is caught and logged. 
	 */
	def performAction(playerName : String, action : Action) {
		agent_says("Performing action **{1}** for player **{0}**", playerName, action.toProlog())
		try {
			// perform the action by agentName in the EIS
			MT_executeAction(playerName, action)
		} catch (e : ActException) {
			if (action !== null)
				warning("Could not perform action {0} for player **{1}**", action, playerName)
		}
	}

}
// /////////////////////////////////////////////////
// END OF FILE
// ///////////////////////////////////////////////// 